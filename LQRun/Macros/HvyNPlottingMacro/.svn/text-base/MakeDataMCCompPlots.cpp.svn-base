#include <iostream>
#include <fstream>
#include <string>
#include <utility>
#include <stdio.h>
#include <stdlib.h>

#include "CompDataMC.hpp"
#include "HistUtils.hpp"


#include "TH1.h"
#include "TDirectory.h"
#include "TFile.h"
#include "TCanvas.h"
#include "TSystem.h"
#include "THStack.h"
#include "TLegend.h"

#include "TROOT.h"
#include <TStyle.h>
#include <cmath> 
#include <map>

#include <sstream>

using namespace std;

int MakePlots();
void MakeCutFlow(std::string hist);

int MakeCutFlow_Plots(string configfile);
void PrintCanvas(TCanvas* c1, std::string folder, std::string title);
bool repeat(string hname);
TLegend* MakeLegend(map<TString, TH1*> legmap,TH1* h_legdata, bool rundata, bool log);
TH1* MakeDataHist(string name, double xmin, double xmax, TH1* h_up,bool ylog , int rebin);
void CheckHist(TH1* h);
void CheckSamples(int nsamples);
vector<pair<TString,float> >  InitSample (TString sample);
THStack* MakeStack(vector<pair<pair<vector<pair<TString,float> >, int >, TString > > sample, TString type, string name, float xmin, float xmax,map<TString, TH1*>& legmap, int rebin);
void SetErrors(TH1* hist, float normerr);
TH1* MakeStackUp(map<TString, TH1*> map_of_stacks, TString clonename);
TH1* MakeStackDown(map<TString, TH1*> map_of_stacks, TString clonename);
TH1* MakeSumHist(THStack* thestack);

float  GetMaximum(TH1* h_data, TH1* h_up, bool ylog, string name);
void SetTitles(TH1* hist, string name);
bool HistInGev(string name);

////// For cutflow
float Error(TH1* h);
float GetTotal(TString cut, vector<pair<TString,float> > sample);
float GetStatError(TString cut, vector<pair<TString,float> > sample);
float GetStatError2(TString cut, vector<pair<TString,float> > sample);
float GetTotalCF(TString cut, vector<pair<TString,float> > sample);
float GetStatErrorCF(TString cut, vector<pair<TString,float> > sample);
float GetStatErrorCF2(TString cut, vector<pair<TString,float> > sample);
float GetIntegral(TString cut, TString isample, TString type);
float GetNormErr(TString cut,  vector<pair<TString,float> > samples);
float GetNormErr2(TString cut,  vector<pair<TString,float> > samples);
float GetErr(TString cut,  vector<pair<TString,float> > samples, TString err_type,TString var);
float GetErr2(TString cut,  vector<pair<TString,float> > samples, TString err_type,TString var);
float GetError(TString cut, TString isample, TString type);

float GetErrCF2(TString cut,  vector<pair<TString,float> > samples, TString err_type,TString var);
float GetErrCF(TString cut,  vector<pair<TString,float> > samples, TString err_type,TString var);

float GetSyst(TString cut, TString syst, pair<vector<pair<TString,float> >,TString > samples );
float GetSystPercent(TString cut, TString syst, pair<vector<pair<TString,float> >,TString > samples );
void setZ(bool useAlpgen);
float Calculate(TString cut, TString variance,  pair<vector<pair<TString,float> >, TString >  samples);

map<string,int> norepeatplot;

std::string hist;
bool showdata=true;
std::string cutfile;
std::string histfile;
bool ylog;
bool usenp(false);
bool useCF(false);

std::string path;
std::string message;
std::string fileprefix="HvyNAnalysis.";
std::string filepostfix = ".NTUP_SMWZ.Reco.root";

vector<pair<pair<string,string>, int> > mcsamples;
vector<pair<pair<string,string>, int> > eemcsamples;
vector<pair<pair<string,string>, int> > sigsamples;

int plotdata;

bool sherpaVV;
bool ALPGENVV;
bool Zalpgen=true;

std::ofstream page;
std::ofstream histpage;

vector<string> cuts; 
vector<string> allcuts; 

//// Standard bkg folders 
string  mcloc ="/afs/hep.man.ac.uk/d/atlas-neutrino_6/2013/Analysis_pro14/MC/"; 
/// SYSTEMATIC folders
string jes_up_mcloc="/afs/hep.man.ac.uk/d/atlas-neutrino_6/2013/Analysis_pro14/MC_JESup/"; 
string jes_down_mcloc="/afs/hep.man.ac.uk/d/atlas-neutrino_6/2013/Analysis_pro14/MC_JESdown/"; 
string jer_mcloc="/afs/hep.man.ac.uk/d/atlas-neutrino_6/2013/Analysis_pro14/MC_JER/"; 
string jvf_up_mcloc="/afs/hep.man.ac.uk/d/atlas-neutrino_6/2013/Analysis_pro14/MC_JVFup/"; 
string jvf_down_mcloc="/afs/hep.man.ac.uk/d/atlas-neutrino_6/2013/Analysis_pro14/MC_JVFdown/"; 


/// Data folder
string dataloc = "/afs/hep.man.ac.uk/d/atlas-neutrino_6/2013/Analysis_pro14/data/"; 


/// data driven
string datadrivenloc= "/afs/hep.man.ac.uk/d/atlas-neutrino_6/2013/Analysis_pro14/MC/"; 
string datadriven_up_loc= "/afs/hep.man.ac.uk/d/atlas-neutrino_6/2013/Analysis_pro14/MC_MMUp/"; 
string datadriven_down_loc= "/afs/hep.man.ac.uk/d/atlas-neutrino_6/2013/Analysis_pro14/MC_MMdown/"; 


//// charge flip
string chargeflip_loc= "/afs/hep.man.ac.uk/d/atlas-neutrino_6/2013/Analysis_pro14/CF/"; 
string chargeflip_up_loc= "/afs/hep.man.ac.uk/d/atlas-neutrino_6/2013/Analysis_pro14/CF_UP/"; 
string chargeflip_down_loc= "/afs/hep.man.ac.uk/d/atlas-neutrino_6/2013/Analysis_pro14/CF_DOWN/"; 


string hist_type;

int main(int argc, char *argv[]) {
  
  /////////////////////////////////////////////////////
  //
  //  3 stages to setup : 
  //  1: McatNloWZ specifies with WZ MC we plot
  //  2: reg: specifies which fake region is plotted
  //  3: BM specifies if we plot 1.2 or 4.7 fb-1
  //
  //////////////////////////////////////////////////////
  
  if(argc == 1) {
    cout << "No config file set" << endl;
    return 0;  
  }

  for (int i = 1; i < argc; ++i) {
    string config = argv[i];   

    int a =MakeCutFlow_Plots(config);
  }

  return 0;
}

int MakeCutFlow_Plots(string configfile){

  if(configfile.find("dat/TriMucuts.txt")!=string::npos) hist_type = "TriMuon";
  if(configfile.find("dat/TriElcuts.txt")!=string::npos) hist_type = "TriEl";
  if(configfile.find("dat/Tri2ElMucuts.txt")!=string::npos) hist_type = "Tri2ElMu";
  if(configfile.find("dat/Tri2MuElcuts.txt")!=string::npos) hist_type = "Tri2MuEl";
  if(configfile.find("dat/SSmm_0jetcuts.txt")!=string::npos) hist_type = "SSmm_0jet";
  if(configfile.find("dat/SSee_0jetcuts.txt")!=string::npos) hist_type = "SSee_0jet";
  if(configfile.find("dat/SSemu_0jetcuts.txt")!=string::npos) hist_type = "SSemu_0jet";
  if(configfile.find("dat/SSmm_wmasscuts.txt")!=string::npos) hist_type = "SSmm_wmass";
  if(configfile.find("dat/SSee_masscuts.txt")!=string::npos) hist_type = "SSee_wmass";
  if(configfile.find("dat/SSemu_wmasscuts.txt")!=string::npos) hist_type = "SSemu_wmass";
  

    
  ifstream setup("Config/config.txt");
  if(!setup) {
    cerr << "Did not find Config/config.txt, exiting ..." << endl;
    return 1;
  }
  while(!setup.eof()) {
    std::string checkend;
    setup >> checkend;
    if(checkend=="END") break;
    setup >> path;
  }
   
  //// Make output webpage path
 
  if(sherpaVV) path+="_VVsherpa";


  TH1::SetDefaultSumw2();
  ////
  
  std::string pname = "/afs/hep.man.ac.uk/u/john/WWW/ATLAS/"+ path + "/indexATLAS.html";
  ///Muons

  std::string phistname = "/afs/hep.man.ac.uk/u/john/WWW/ATLAS/"+ path + "/histograms/" + hist_type  + "/indexATLAS.html";

  system(("mkdir /afs/hep.man.ac.uk/u/john/WWW/ATLAS/" + path).c_str());
  system(("mkdir /afs/hep.man.ac.uk/u/john/WWW/ATLAS/" + path+ "/histograms/").c_str());

  system(("mkdir /afs/hep.man.ac.uk/u/john/WWW/ATLAS/" + path+"/histograms/" + hist_type + "/").c_str());

  cout << "HIST page is set to " << phistname.c_str() << endl;
  histpage.open(phistname.c_str());

  page.open(pname.c_str());
  page << "<html><font face=\"Helvetica\"><head><title> HvyN Analysis </title></head>" << endl;
  page << "<body>" << endl;
  page << "<h1> HvyN Analysis Plots </h1>" << endl;
  page << "<br> <font size=\"4\"><b> " << message <<  " </b></font> <br><br>" << endl;
  
  page << "<a href=\"histograms/" +hist_type + "/indexATLAS.html\">"+ hist_type + "</a><br>"; 
  
  int M=MakePlots();  
  //  MakeCutFlow(hist_type);

  return M;

}


void MakeCutFlow(string type){
  
  TString columnname="";
  TString caption="";
  
  
  vector<TString> cuts;
  vector<string> cut_label;
    

  if(hist_type.find("SSmm_0jet")!=string::npos){
    caption="Expected and observed number of events containing two muons with same charge and zero jets. The uncertainties are stated as statistical followed by systematic.";
    
    cut_label.push_back("SSmm_0jet");
    hist = "SSMuonPlots/mu1_eta";
    columnname="$\\mu^{\\pm}\\mu^{\\pm} + \\rm{0 jets}$";
    
    showdata=true;
    cutfile = "dat/SSmm_0jetcuts.txt";
  }

  if(hist_type.find("SSee_0jet")!=string::npos){
    caption="Expected and observed number of events containing two electrons with same charge and zero jets. The uncertainties are stated as statistical followed by systematic.";
    
    cut_label.push_back("SSee_0jet");
    hist = "SSElectronPlots/el1_eta";
    columnname="$e^{\\pm}e^{\\pm} + \\rm{0~jets}$";
    
    showdata=true;
    cutfile = "dat/SSee_0jetcuts.txt";
  }

  if(hist_type.find("SSemu_0jet")!=string::npos){
    caption="Expected and observed number of events containing one muon and one electron with same charge and zero jets. The uncertainties are stated as statistical followed by systematic.";
    
    cut_label.push_back("SSemu_0jet");
    hist = "SSMuonPlots/mu1_eta";
    columnname="$e^{\\pm}\\mu^{\\pm} + \\rm{0 jets}$";
    
    showdata=true;
    cutfile = "dat/SSemu_0jetcuts.txt";
  }


   if(hist_type.find("SSmm_wmass")!=string::npos){
    caption="Expected and observed number of events containing two muons with same charge, $E^{miss}_{T}<40$~GeV and m(jj) in W mass window. The uncertainties are stated as statistical followed by systematic.";
    
    cut_label.push_back("SSmm_wmass");
    hist = "SSMuonPlots/mu1_eta";
    columnname="$\\mu^{\\pm}\\mu^{\\pm} (signal region)$";
    
    showdata=false;
    cutfile = "dat/SSmm_wmasscuts.txt";
  }

  if(hist_type.find("SSee_wmass")!=string::npos){
    caption="Expected and observed number of events containing two electrons with same charge and zero jets. The uncertainties are stated as statistical followed by systematic.";
    
    cut_label.push_back("SSee_0jet");
    hist = "SSElectronPlots/el1_eta";
    columnname="$e^{\\pm}e^{\\pm} + \\rm{0~jets}$";
    
    showdata=false;
    cutfile = "dat/SSee_0jetcuts.txt";
  }

  if(hist_type.find("SSemu_wmass")!=string::npos){
    caption="Expected and observed number of events containing one muon and one electron with same charge and zero jets. The uncertainties are stated as statistical followed by systematic.";
    
    cut_label.push_back("SSemu_0jet");
    hist = "SSMuonPlots/mu1_eta";
    columnname="$e^{\\pm}\\mu^{\\pm} + \\rm{0 jets}$";
    
    showdata=false;
    cutfile = "dat/SSemu_0jetcuts.txt";
  }




  if(hist_type.find("TriMuon")!=string::npos){
    caption="Expected and observed number of events containing three isolated muons. The uncertainties are stated as statistical followed by systematic.";
    
    cut_label.push_back("TriMu");
    hist = "MuonPlots/mu1_eta";
    columnname="$\\mu^{\\pm}\\mu^{\\mp}\\mu^{\\pm}$";
    
    showdata=true;
    cutfile = "dat/TriMucuts.txt";
  }

  if(hist_type.find("TriEl")!=string::npos){
    caption="Expected and observed number of events containing three isolated electrons. The uncertainties are stated as statistical followed by systematic.";
    
    cut_label.push_back("TriEl");    
    columnname="$e^{\\pm}e^{\\mp}e^{\\pm}$";
    hist = "ElectronPlots/el1_eta" ;

    showdata=true;
    cutfile = "dat/TriElcuts.txt";
  }


  
  if(hist_type.find("Tri2MuEl")!=string::npos){
    caption="Expected and observed number of events containing two isolated opposite charged muons and one electrons. The uncertainties are stated as statistical followed by systematic.";
    
    cut_label.push_back("Tri2MuEl");    
    columnname="$\\mu^{\\pm}\\mu^{\\mp}e^{\\pm}$";
    hist = "ElectronPlots/el1_eta" ;

    showdata=true;
    cutfile = "dat/Tri2MuElcuts.txt";
  }


    if(hist_type.find("Tri2ElMu")!=string::npos){
    caption="Expected and observed number of events containing two isolated opposite charged electrons and one muon. The uncertainties are stated as statistical followed by systematic.";
    
    cut_label.push_back("Tri2ElMu");    
    columnname="$e^{\\pm}e^{\\mp}\\mu^{\\pm}$";
    hist = "ElectronPlots/el1_eta" ;

    showdata=true;
    cutfile = "dat/Tri2ElMucuts.txt";
  }

  cuts.clear();    
  // ----------Get list of cuts to plot  ----------------------
  ifstream cut_name_file(cutfile.c_str());
  while(!cut_name_file.eof()) {
    string cutname;
    cut_name_file >> cutname;
    if(cutname=="END") break;
    cuts.push_back((hist + cutname).c_str());    
    cout << "Making cutflow for MuonPlots/mu1_eta"<< cutname << endl;
  }

  
	
  vector<float> totalnumbers;
  vector<float> totalnumbersup;
  vector<float> totalnumbersdown;  
  
  int i_cut(0);
  for(vector<TString>::iterator it = cuts.begin(); it!=cuts.end(); it++, i_cut++){
    
    vector<pair<TString,float> > np;
  
    vector<pair<TString,float> > higgs = InitSample("higgs");
    vector<pair<TString,float> > top = InitSample("top");
    vector<pair<TString,float> > wz = InitSample("wz_sherpa");
    vector<pair<TString,float> > zz = InitSample("zz_sherpa");
    vector<pair<TString,float> > vtt = InitSample("vtt_madgraph");
    vector<pair<TString,float> > vvv = InitSample("vvv");
    vector<pair<TString,float> > ssww = InitSample("ssww");
    vector<pair<TString,float> > ww = InitSample("ww_sherpa");
    vector<pair<TString,float> > z = InitSample("z_alpgen");
    vector<pair<TString,float> > cf = InitSample("CF");

  
    if(usenp)np.push_back(make_pair("datadriven",0.));

  
    vector<pair<vector<pair<TString,float> >, TString> > samples;
    
    if(!useCF){
      samples.push_back(make_pair(wz,"WZ"));
      samples.push_back(make_pair(zz,"ZZ"));
      samples.push_back(make_pair(vtt,"V(V)tt"));
      samples.push_back(make_pair(ssww,"SSww"));
      samples.push_back(make_pair(vvv,"VVV"));
      samples.push_back(make_pair(z,"Z"));
      samples.push_back(make_pair(ww,"WW"));
      samples.push_back(make_pair(top,"Top"));         
      samples.push_back(make_pair(higgs,"Higgs"));
      if(usenp)samples.push_back(make_pair(np,"NonPrompt"));

    }
    else{
      samples.push_back(make_pair(cf,"CF"));
      samples.push_back(make_pair(wz,"WZ"));
      samples.push_back(make_pair(zz,"ZZ"));
      samples.push_back(make_pair(vtt,"V(V)tt"));
      samples.push_back(make_pair(ssww,"SSww"));
      samples.push_back(make_pair(vvv,"VVV"));
      samples.push_back(make_pair(top,"Top"));         
      samples.push_back(make_pair(higgs,"Higgs"));
      if(usenp)samples.push_back(make_pair(np,"NonPrompt"));
    }
  
    
    /// Vectors for cutflow	table
    map<TString,float> samples_numbers;
    map<TString,float> samples_numbers_staterr;
    map<TString,float> samples_numbers_up;
    map<TString,float> samples_numbers_down;
    
    /// Vector for systematic table
    map<TString,float> syst_stat;
    map<TString,float> syst_JESup;
    map<TString,float> syst_JESdown;
    map<TString,float> syst_JVFup;
    map<TString,float> syst_JVFdown;
    map<TString,float> syst_JER;
    map<TString,float> syst_norm;
    map<TString,float> syst_total;

    
    float totalbkg(0.),totalbkgdown(0.), totalbkgup(0.); 
    for(vector<pair<vector<pair<TString,float> >, TString> >::iterator it2 = samples.begin() ; it2!= samples.end(); it2++){
      
      
      TString cutname = *it;
      totalbkg+= Calculate(*it,"Normal",*it2);
      totalbkgup+= Calculate(*it,"Up",*it2);
      totalbkgdown+= Calculate(*it,"Down",*it2);
      
      samples_numbers[it2->second] = Calculate(cutname,"Normal",*it2);
      samples_numbers_up[it2->second] = Calculate(cutname,"Down",*it2);
      samples_numbers_down[it2->second] = Calculate(cutname,"Up",*it2);
      samples_numbers_staterr[it2->second] = Calculate(cutname,"StatErr",*it2);
    }	
    
    
    float totaldata(0.);
    if(showdata) totaldata = GetIntegral(*it,"data","data");
    float errdata(0.);
    if(showdata) errdata= GetError(*it,"data","data");
    
    
    float totalerr_up(0.),totalerr_down(0.),totalerrup(0.),totalerrdown(0.),total_staterr(0.);
    for(map<TString,float>::iterator mapit = samples_numbers.begin(); mapit!= samples_numbers.end(); mapit++){
      
      map<TString,float>::iterator mapit_up;
      mapit_up = samples_numbers_up.find(mapit->first);
      map<TString,float>::iterator mapit_down;
      mapit_down = samples_numbers_down.find(mapit->first);
      map<TString,float>::iterator mapit_stat;
      mapit_stat = samples_numbers_staterr.find(mapit->first);
      totalerr_up += ( mapit_up->second*mapit_up->second+ mapit_stat->second*mapit_stat->second); 
      totalerr_down += (mapit_down->second*mapit_down->second + mapit_stat->second*mapit_stat->second); 
      totalerrup += (mapit_up->second*mapit_up->second); 
      totalerrdown += (mapit_down->second*mapit_down->second); 
      total_staterr += mapit_stat->second*mapit_stat->second;
      cout << mapit->first << " background = " << mapit->second << " +- " << mapit_stat->second << " + " << mapit_up->second << " - " << mapit_down->second <<  endl;      
   
      
    }
  
    
    totalerr_up = sqrt(totalerr_up);
    totalerr_down = sqrt(totalerr_down);
    total_staterr = sqrt(total_staterr);
    totalerrup = sqrt(totalerrup);
    totalerrdown = sqrt(totalerrdown);
    
    cout << "Total Bkg   = " << totalbkg << "+- " << total_staterr << " + " << totalerrup << " - " << totalerrdown << endl;
    if(showdata)cout << "Total Data  = " << totaldata << endl;
    cout << "-------------" << endl;
    if(totaldata > totalbkg)cout <<"Significance = " << (totaldata - totalbkg) / (sqrt( (errdata*errdata) + (totalerr_up*totalerr_up))) << endl;
    else cout <<"Significance = " << (totaldata - totalbkg) / (sqrt( (errdata*errdata) + (totalerr_down*totalerr_down))) << endl;
    float significance = (totaldata - totalbkg) / (sqrt( (errdata*errdata) + (totalerr_up*totalerr_up))) ;
    
    if(significance < 0.) significance = (totaldata - totalbkg) / (sqrt( (errdata*errdata) + (totalerr_down*totalerr_down))) ;
    
    ofstream ofile;
    
    string latex =  "Tables/" + cut_label.at(i_cut) + "Table.txt";
    
    ofile.open(latex.c_str());
    ofile.setf(ios::fixed,ios::floatfield); 
    
    ofile.precision(1);
    ofile << "\\begin{table}[h]" << endl;
    ofile << "\\begin{center}" << endl;
    ofile << "\\begin{tabular}{lr@{\\hspace{0.5mm}}c@{\\hspace{0.5mm}}c@{\\hspace{0.5mm}}l}" << endl;
    ofile << "\\hline" << endl;
    ofile << "\\hline" << endl;   
    //ofile << "Source & \\multicolumn{4}{c}{$\\mu\\mu\\mu$} \\"<<"\\" << endl;
    ofile << "Source & \\multicolumn{4}{c}{" << columnname << "} \\"<<"\\" << endl;
    ofile << "\\hline" << endl;   
	 
    
    for(map<TString,float>::iterator mapit = samples_numbers.begin(); mapit!= samples_numbers.end(); mapit++){
      
      map<TString,float>::iterator mapit_up;
      mapit_up = samples_numbers_up.find(mapit->first);
      map<TString,float>::iterator mapit_down;
      mapit_down = samples_numbers_down.find(mapit->first);
      map<TString,float>::iterator mapit_stat;
      mapit_stat = samples_numbers_staterr.find(mapit->first);
      
      if(mapit->second!=0.0){
	ofile << mapit->first + "&" <<  mapit->second << "& $\\pm$& "  << mapit_stat->second <<  "&$^{+" <<  mapit_up->second << "}_{-" <<  mapit_down->second  << "}$" ; 
	ofile  <<  "\\"  << "\\" << endl;	   
      }
    }
    ofile << "\\hline" << endl;
    ofile << "Total&" << totalbkg << "& $\\pm$&"  << total_staterr << "&$^{+" << totalerrup  << "}_{-" << totalerrdown << "}$" ; 
    ofile  <<  "\\"  << "\\" << endl;
    ofile << "\\hline" << endl;
    
    ofile << "Data&  \\multicolumn{4}{c}{$" << totaldata << "$}\\" << "\\" <<endl;
    ofile << "\\hline" << endl;
    if(significance < 0) ofile << "Signficance&  \\multicolumn{4}{c}{$" << significance << "\\sigma$}\\" << "\\" <<endl;
    if(significance > 0) ofile << "Signficance&  \\multicolumn{4}{c}{$+" << significance << "\\sigma$}\\" << "\\" <<endl;
    ofile << "\\hline" << endl;   
    ofile << "\\hline" << endl;   
    ofile << "\\end{tabular}" << endl;
    ofile << "\\caption{" << caption << "}" << endl;
    ofile << "\\end{center}" << endl;
    ofile << "\\end{table}" << endl;    
  }
  
  
  string latex_command = "latex Tables/" + cut_label.at(0) +".tex";
  string dvi_command = "dvipdf " + cut_label.at(0) +".dvi";
  string mv_command = "mv " + cut_label.at(0) +".pdf /afs/hep.man.ac.uk/u/john/WWW/ATLAS/" + path +"/histograms/"+ hist_type ;
  
  system((latex_command.c_str()));
  system((dvi_command.c_str()));
  system((mv_command.c_str()));
  system(("rm *aux"));
  system(("rm *log"));
  system(("rm *dvi"));
  
  string cftitle = cut_label.at(0);
  
  histpage << "<tr><td>"<< "cutflow " + cut_label.at(0)  <<"</td>"<<endl;
  histpage <<"<td>"<<endl;
  histpage << "<a href=\"" << cut_label.at(0)  << ".pdf\">";
  histpage << "<img src=\"" << cut_label.at(0)  << ".pdf\" width=\"100%\"/>";
  histpage << "</td>" << endl;

  
  return;
}

int MakePlots() {

  
  /// colours of histograms
  int tcol(0), zzcol(0), fcol(0), zcol(0), wzcol(0), sscol(0), higgscol(0), stopcol(0), wwcol(0), vvvcol(0);
  
  // Get list of cuts to plot  
  ifstream colour_name_file("Config/colour.txt");
  if(!colour_name_file) {
    cerr << "Did not find Config/colour.txt, exiting ..." << endl;
    return 1;
  }
  while(!colour_name_file.eof()) {        
    string histname;
    int col;
    colour_name_file >> histname;    
    if(histname=="END") break;
    colour_name_file >> col;

    if(histname=="tcol") tcol =col;
    if(histname=="zzcol") zzcol =col;
    if(histname=="fcol") fcol =col;
    if(histname=="zcol") zcol =col;
    if(histname=="wzcol")wzcol =col;
    if(histname=="sscol") sscol =col;
    if(histname=="higgscol")higgscol =col;
    if(histname=="stopcol") stopcol =col;
    if(histname=="wwcol") wwcol =col;
    if(histname=="vvvcol") vvvcol =col;
    cout << "Set sample " << histname << " with colour " << col  << endl;
  }
  
  
  vector<pair<TString,float> > higgs = InitSample("higgs");
  vector<pair<TString,float> > top = InitSample("top");
  vector<pair<TString,float> > wz = InitSample("wz_sherpa");
  vector<pair<TString,float> > zz = InitSample("zz_sherpa");
  vector<pair<TString,float> > vtt = InitSample("vtt_madgraph");
  vector<pair<TString,float> > vvv = InitSample("vvv");
  vector<pair<TString,float> > ssww = InitSample("ssww");
  vector<pair<TString,float> > z = InitSample("z_alpgen");
  vector<pair<TString,float> > cf = InitSample("CF");
  
  
  vector<pair<TString,float> > np;
  np.push_back(make_pair("datadriven",0.));
  


  ////////////////////// ////////////////
  ////  MAIN PART OF CODE for user/
  ///////////////////////////////////////
  //// What samples to use in histogram
  vector<pair<pair<vector<pair<TString,float> >, int >, TString > > samples;
  
  if(hist_type.find("SSmm_0jet")!=string::npos){
    
    usenp=true;
    plotdata = true;
    ylog=false;
    cutfile = "dat/SSmm_0jetcuts.txt";
    histfile = "dat/SSmm_0jethist_config.txt";
    samples.push_back(make_pair(make_pair(vtt,tcol),"Top+X"));
    samples.push_back(make_pair(make_pair(ssww,sscol),"SSww"));
    samples.push_back(make_pair(make_pair(vvv,vvvcol),"VVV"));
    samples.push_back(make_pair(make_pair(higgs,higgscol),"Higgs"));
    samples.push_back(make_pair(make_pair(zz,zzcol),"ZZ"));
    samples.push_back(make_pair(make_pair(wz,wzcol),"WZ"));
    samples.push_back(make_pair(make_pair(np,fcol),"Non Prompt"));
  }

   
  if(hist_type.find("SSee_0jet")!=string::npos){
    useCF=true;
    usenp=true;
    plotdata = true;
    ylog=false;
    cutfile = "dat/SSee_0jetcuts.txt";
    histfile = "dat/SSee_0jethist_config.txt";

    samples.push_back(make_pair(make_pair(ssww,sscol),"SSww"));
    samples.push_back(make_pair(make_pair(higgs,higgscol),"Higgs"));
    samples.push_back(make_pair(make_pair(zz,zzcol),"ZZ"));
    samples.push_back(make_pair(make_pair(wz,wzcol),"WZ"));
    samples.push_back(make_pair(make_pair(np,fcol),"Non Prompt"));
    samples.push_back(make_pair(make_pair(cf,zcol),"CF"));
  }


  if(hist_type.find("SSmm_wmass")!=string::npos){
    useCF=true;
    usenp=true;
    showdata=false;
    plotdata = false;
    ylog=false;
    cutfile = "dat/SSmm_wmasscuts.txt";
    histfile = "dat/SSmm_wmasshist_config.txt";

    samples.push_back(make_pair(make_pair(ssww,sscol),"SSww"));
    samples.push_back(make_pair(make_pair(higgs,higgscol),"Higgs"));
    samples.push_back(make_pair(make_pair(zz,zzcol),"ZZ"));
    samples.push_back(make_pair(make_pair(wz,wzcol),"WZ"));
    samples.push_back(make_pair(make_pair(vvv,vvvcol),"VVV"));
    samples.push_back(make_pair(make_pair(vtt,tcol),"Top+X"));
    samples.push_back(make_pair(make_pair(np,fcol),"Non Prompt"));
  }

 
  if(hist_type.find("SSemu_0jet")!=string::npos){    
    usenp=true;
    plotdata = true;
    ylog=false;
    cutfile = "dat/SSemu_0jetcuts.txt";
    histfile = "dat/SSemu_0jethist_config.txt";
    samples.push_back(make_pair(make_pair(vtt,tcol),"Top+X"));
    samples.push_back(make_pair(make_pair(ssww,sscol),"SSww"));
    samples.push_back(make_pair(make_pair(vvv,vvvcol),"VVV"));
    samples.push_back(make_pair(make_pair(higgs,higgscol),"Higgs"));
    samples.push_back(make_pair(make_pair(zz,zzcol),"ZZ"));
    samples.push_back(make_pair(make_pair(wz,wzcol),"WZ"));
    samples.push_back(make_pair(make_pair(np,fcol),"Non Prompt"));
  }
  
  cout << histfile << endl;
  
  if(hist_type.find("TriMuon")!=string::npos){
    usenp=false;
    plotdata = true;
    ylog=false;
    cutfile = "dat/TriMucuts.txt";
    histfile = "dat/TriMuhist_config.txt";
    samples.push_back(make_pair(make_pair(vtt,tcol),"Top+X"));
    samples.push_back(make_pair(make_pair(ssww,sscol),"SSww"));
    samples.push_back(make_pair(make_pair(vvv,vvvcol),"VVV"));
    samples.push_back(make_pair(make_pair(higgs,higgscol),"Higgs"));
    samples.push_back(make_pair(make_pair(zz,zzcol),"ZZ"));
    samples.push_back(make_pair(make_pair(wz,wzcol),"WZ"));
  }

 
  if(hist_type.find("TriEl")!=string::npos){
    usenp=false;
    plotdata = true;
    ylog=false;
    cutfile = "dat/TriElcuts.txt";
    histfile = "dat/TriElhist_config.txt";
    samples.push_back(make_pair(make_pair(vtt,tcol),"Top+X"));
    samples.push_back(make_pair(make_pair(ssww,sscol),"SSww"));
    samples.push_back(make_pair(make_pair(vvv,vvvcol),"VVV"));
    samples.push_back(make_pair(make_pair(higgs,higgscol),"Higgs"));
    samples.push_back(make_pair(make_pair(zz,zzcol),"ZZ"));
    samples.push_back(make_pair(make_pair(wz,wzcol),"WZ"));
    samples.push_back(make_pair(make_pair(z,zcol),"Z"));
  }

  if(hist_type.find("Tri2MuEl")!=string::npos){
    usenp=false;
    plotdata = true;
    ylog=false;
    cutfile = "dat/Tri2MuElcuts.txt";
    histfile = "dat/Tri2MuElhist_config.txt";
    samples.push_back(make_pair(make_pair(vtt,tcol),"Top+X"));
    samples.push_back(make_pair(make_pair(ssww,sscol),"SSww"));
    samples.push_back(make_pair(make_pair(vvv,vvvcol),"VVV"));
    samples.push_back(make_pair(make_pair(higgs,higgscol),"Higgs"));
    samples.push_back(make_pair(make_pair(zz,zzcol),"ZZ"));
    samples.push_back(make_pair(make_pair(wz,wzcol),"WZ"));
    samples.push_back(make_pair(make_pair(z,zcol),"Z"));
  }


   if(hist_type.find("Tri2ElMu")!=string::npos){
     usenp=false;
     plotdata = true;
     ylog=false;
     cutfile = "dat/Tri2ElMucuts.txt";
     histfile = "dat/Tri2ElMuhist_config.txt";
     samples.push_back(make_pair(make_pair(vtt,tcol),"Top+X"));
     samples.push_back(make_pair(make_pair(ssww,sscol),"SSww"));
     samples.push_back(make_pair(make_pair(vvv,vvvcol),"VVV"));
     samples.push_back(make_pair(make_pair(higgs,higgscol),"Higgs"));
     samples.push_back(make_pair(make_pair(zz,zzcol),"ZZ"));
     samples.push_back(make_pair(make_pair(wz,wzcol),"WZ"));
     samples.push_back(make_pair(make_pair(z,zcol),"Z"));
  }
  
  
  cuts.clear();    

  // ----------Get list of cuts to plot  ----------------------
  ifstream cut_name_file(cutfile.c_str());
  if(!cut_name_file) {
    cerr << "Did not find dat/cuts.txt, exiting ..." << endl;
    return 1;
  }
  while(!cut_name_file.eof()) {
    string cutname;
    cut_name_file >> cutname;
    if(cutname=="END") break;
    allcuts.push_back(cutname);
    cout << "Added " << cutname << endl;
  }
  
  
  ifstream histo_name_file(histfile.c_str());
  if(!histo_name_file) {
    cerr << "Did not find dat/hist_config.txt, exiting ..." << endl;
    return 1;
  }
  
  histpage << "<table border = 1><tr>"
	   << "<th> <a name=\"Cut : Plot\">Cut : Plot</a> </th>"
	   << "<th> Plots </th>"
	   << "</tr>" << endl;
  
  while(!histo_name_file.eof()) {
    string h_name;
    int rebin;
    double xmin,xmax,ymin, ymax;
    histo_name_file >> h_name;
    if(repeat(h_name))continue;
    if(h_name=="END") break;
    histo_name_file >> rebin;
    histo_name_file >> xmin;
    histo_name_file >> xmax;
    
    if(h_name.find("#")!=string::npos) continue;
    
    for(unsigned int ncut=0; ncut<allcuts.size();  ncut++){
      string name = h_name+allcuts.at(ncut);

	
	cout << "\n------------------------------------------------------- \n" << endl;
	cout << "Making histogram " << name << endl;
	
	
	/// Make nominal histogram stack
	map<TString, TH1*> legmap;
	THStack* mstack=  MakeStack(samples , "Nominal",name, xmin, xmax, legmap, rebin );
	
	
	//// mhist sets error config
	map<TString,TH1*> mhist;
	mhist["Nominal"] = MakeSumHist(mstack);
	mhist["JESup"] = MakeSumHist(MakeStack(samples , "JESup",name, xmin, xmax, legmap, rebin  ));
	mhist["JESdown"] = MakeSumHist(MakeStack(samples , "JESdown",name, xmin, xmax , legmap, rebin ));
	mhist["JER"] = MakeSumHist(MakeStack(samples , "JER",name, xmin, xmax , legmap, rebin ));
	mhist["JVFup"] = MakeSumHist(MakeStack(samples , "JVFup",name, xmin, xmax, legmap , rebin ));
	mhist["JVFdown"] = MakeSumHist(MakeStack(samples , "JVFdown",name, xmin, xmax, legmap, rebin  ));	
	if(usenp)mhist["FakeUp"] = MakeSumHist(MakeStack(samples , "FakeUp",name, xmin, xmax, legmap, rebin  ));	
	if(usenp)mhist["FakeDown"] = MakeSumHist(MakeStack(samples , "FakeDown",name, xmin, xmax, legmap, rebin  ));	
	
	
	TH1* hup = MakeStackUp(mhist, name+"UP");
	TH1* hdown = MakeStackDown(mhist, name+"DOWN");

	
	
	cout << "Final Background Integral = " <<  MakeSumHist(mstack)->Integral() << " : Up = " << hup->Integral() << " : Down= " << hdown->Integral() << endl;
	
	/// Make data histogram
	TH1* hdata = MakeDataHist(name, xmin, xmax, hup, ylog, rebin);
	CheckHist(hdata);	
	if(showdata)cout << "Total data = " <<  hdata->Integral() << endl;
	

	/// Make legend
	TLegend* legend = MakeLegend(legmap, hdata, showdata, ylog);       		
	
        vector<THStack*> vstack;		
	vstack.push_back(mstack);   
	
	TCanvas* c = CompDataMC(hdata, vstack,hup,hdown, legend,name,rebin,xmin,xmax,path, hist_type,false, showdata);      
	
	PrintCanvas(c, hist_type, c->GetName());
      }
    }
    
    
    
    page.close();

    return 0;
}


bool repeat (string hname){
  map<string,int>::iterator mit = norepeatplot.find(hname);
  if(mit!=norepeatplot.end())return true;
  else{
    norepeatplot[hname]=1;
    return false;
  }
}



//////////////////////////////////////////////////////////////////////////////////////////////////////////////
void PrintCanvas(TCanvas* c1, string folder, string title){

  std::string tpdf = "/afs/hep.man.ac.uk/u/john/WWW/ATLAS/"+ path +  "/histograms/"+folder+"/"+title;
  string plot_description;

  plot_description = title;
  
  
  if(plot_description.empty())plot_description=title;
  histpage << "<tr><td>"<< plot_description <<"</td>"<<endl;
  histpage <<"<td>"<<endl;
  histpage << "<a href=\"" << title.c_str() << ".pdf\">";
  histpage << "<img src=\"" << title.c_str() << ".pdf\" width=\"100%\"/>";
  histpage << "</td>" << endl;
  


  return;
  
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////


TLegend* MakeLegend(map<TString, TH1*> map_legend,TH1* hlegdata,  bool rundata , bool logy){
  
  double x1 = 0.75;
  double y1 = 0.75;
  double x2 = 0.92;
  double y2 = 0.9999;

  if(!showdata){
    x1= 0.6;
    x2= 0.8;
    y1= 0.6;
    y2= 0.8;
  }

  TLegend* legendH = new TLegend(x1,y1,x2,y2);
  legendH->SetFillColor(10);
  legendH->SetBorderSize(0);
  legendH->SetTextSize(0.04);
  
  
  if(rundata) 	legendH->AddEntry(hlegdata,"Data","pl");
  
  for(map<TString, TH1*>::iterator it = map_legend.begin(); it!= map_legend.end(); it++){
    legendH->AddEntry(it->second,it->first.Data(),"f");    
  }

  return legendH;
  
}




TH1* MakeDataHist(string name, double xmin, double xmax, TH1* hup, bool ylog, int rebin){

  /// Make data histogram
  TFile* file_data =  TFile::Open((dataloc+"HvyNAnalysis.data.NTUP_SMWZ.Reco.root").c_str());
  TH1* hdata = dynamic_cast<TH1*> ((file_data->Get(name.c_str()))->Clone());
  
  hdata->Rebin(rebin);

  float ymin (0.), ymax( 1000000.);
  if(ylog) ymin= 0.1;
  ymax = GetMaximum(hdata, hup, ylog, name);
  
  /// Set Ranges / overflows
  FixOverUnderFlows(hdata, xmax);  
  
  cout << "Ymax = " << ymax << endl;
  hdata->GetXaxis()->SetRangeUser(xmin,xmax);
  hdata->GetYaxis()->SetRangeUser(ymin, ymax);

  hdata->SetMarkerStyle(20);
  hdata->SetMarkerSize(1.2);
	
 
  //// X title  
  SetTitles(hdata, name);
  
  return hdata;

}

void CheckHist(TH1* h){
  if(!h) {
    cout << "Not able to find data histogram" << endl;
    exit(1);
  }
}


vector<pair<TString,float> >  InitSample (TString sample){
  
  vector<pair<TString,float> > list;  
  
  //// Higgs sample /////
  if(sample.Contains("higgs")){
    list.push_back(make_pair("higgs",0.3));
  }


  if(sample.Contains("CF")){
    list.push_back(make_pair("Z",0.2));    
  }

  ///// Top samples //////////////////    
  if(sample.Contains("top")){
    list.push_back(make_pair("ttbar",0.1));
    //    list.push_back(make_pair("schan_mu",0.1));
    //    list.push_back(make_pair("schan_e",0.1));
    //    list.push_back(make_pair("schan_tau",0.1));
    //    list.push_back(make_pair("Wt",0.1));
    //    list.push_back(make_pair("tchan_mu",0.1));
    //    list.push_back(make_pair("tchan_e",0.1));
    //    list.push_back(make_pair("tchan_tau",0.1));
  }
  //////// Diboson ////////
  if(sample.Contains("wz_sherpa")){    
    list.push_back(make_pair("WZ_sherpa",0.15));
    list.push_back(make_pair("WZ_sherpa_ew6",0.15));
  }
  
  if(sample.Contains("zz_sherpa")){
    list.push_back(make_pair("ZZ",0.15));
    list.push_back(make_pair("ZZllnunu",0.15));
    list.push_back(make_pair("ZZ_sherpa_ew6",0.15));
  }
  
  if(sample.Contains("ww_sherpa")){      
    list.push_back(make_pair("WW_sherpa",0.12));
  }

  //////// SS WW /////////  
  if(sample.Contains("ssww")){         
    list.push_back(make_pair("SSWW_cteq",0.5));              
  }


  ///Tri Bosons ;//////
  if(sample.Contains("vvv")){         
    list.push_back(make_pair("WWW",0.5));
    list.push_back(make_pair("ZWW",0.5));
    list.push_back(make_pair("ZZZ",0.5));
  }
  
  /// ALPGEN                                                                                                                                                                        
  if(sample.Contains("vtt_alpgen")){         
    list.push_back(make_pair("WWtt",0.5));
    list.push_back(make_pair("ttZllNp0",0.5));
    list.push_back(make_pair("ttZllNp1",0.5));
    list.push_back(make_pair("ttZllNp2",0.5));
    list.push_back(make_pair("ttZllNp3",0.5));
    list.push_back(make_pair("ttWqqNp0",0.5));
    list.push_back(make_pair("ttWqqNp1",0.5));
    list.push_back(make_pair("ttWqqNp2",0.5));
    list.push_back(make_pair("ttWqqNp3",0.5));
    list.push_back(make_pair("ttWlnuNp0",0.5));
    list.push_back(make_pair("ttWlnuNp1",0.5));
    list.push_back(make_pair("ttWlnuNp2",0.5));
    list.push_back(make_pair("ttWlnuNp3",0.5));
  }
  if(sample.Contains("vtt_madgraph")){         
    list.push_back(make_pair("ttWW_cteq",0.5));
    list.push_back(make_pair("Wtt",0.5));
    list.push_back(make_pair("Wttj",0.5));
    list.push_back(make_pair("Ztt",0.5));
    list.push_back(make_pair("Zttj",0.5));
  }
  
  
  if(sample.Contains("z_alpgen")){         
    list.push_back(make_pair("ZmumuNp0",0.1));
    list.push_back(make_pair("ZmumuNp1",0.1));
    list.push_back(make_pair("ZmumuNp2",0.1));
    list.push_back(make_pair("ZmumuNp3",0.1));
    list.push_back(make_pair("ZmumuNp4",0.1));
    list.push_back(make_pair("ZmumuNp5",0.1));
    list.push_back(make_pair("ZLMmumuNp0",0.1));
    list.push_back(make_pair("ZLMmumuNp1",0.1));
    list.push_back(make_pair("ZLMmumuNp2",0.1));
    list.push_back(make_pair("ZLMmumuNp3",0.1));
    list.push_back(make_pair("ZLMmumuNp4",0.1));
    list.push_back(make_pair("ZLMmumuNp5",0.1));    
    list.push_back(make_pair("ZtautauNp0",0.1));
    list.push_back(make_pair("ZtautauNp1",0.1));
    list.push_back(make_pair("ZtautauNp2",0.1));
    list.push_back(make_pair("ZtautauNp3",0.1));
    list.push_back(make_pair("ZtautauNp4",0.1));
    list.push_back(make_pair("ZtautauNp5",0.1));
    list.push_back(make_pair("ZtautauLMNp0",0.1));
    list.push_back(make_pair("ZtautauLMNp1",0.1));
    list.push_back(make_pair("ZtautauLMNp2",0.1));
    list.push_back(make_pair("ZtautauLMNp3",0.1));
    list.push_back(make_pair("ZtautauLMNp4",0.1));
    list.push_back(make_pair("ZtautauLMNp5",0.1));
    list.push_back(make_pair("ZmumubbNp0",0.1));
    list.push_back(make_pair("ZmumubbNp1",0.1));
    list.push_back(make_pair("ZmumubbNp2",0.1));
    list.push_back(make_pair("ZmumubbNp3",0.1));
    list.push_back(make_pair("ZmumuccNp0",0.1));
    list.push_back(make_pair("ZmumuccNp1",0.1));
    list.push_back(make_pair("ZmumuccNp2",0.1));
    list.push_back(make_pair("ZmumuccNp3",0.1));    
    list.push_back(make_pair("ZtautaubbNp0",0.1));
    list.push_back(make_pair("ZtautaubbNp1",0.1));
    list.push_back(make_pair("ZtautaubbNp2",0.1));
    list.push_back(make_pair("ZtautaubbNp3",0.1));
    list.push_back(make_pair("ZtautauccNp0",0.1));
    list.push_back(make_pair("ZtautauccNp1",0.1));
    list.push_back(make_pair("ZtautauccNp2",0.1));
    list.push_back(make_pair("ZtautauccNp3",0.1));        
    list.push_back(make_pair("ZeeNp0",0.1));
    list.push_back(make_pair("ZeeNp1",0.1));
    list.push_back(make_pair("ZeeNp2",0.1));
    list.push_back(make_pair("ZeeNp3",0.1));
    list.push_back(make_pair("ZeeNp4",0.1));
    list.push_back(make_pair("ZeeNp5",0.1));
    list.push_back(make_pair("ZLMeeNp0",0.1));
    list.push_back(make_pair("ZLMeeNp1",0.1));
    list.push_back(make_pair("ZLMeeNp2",0.1));
    list.push_back(make_pair("ZLMeeNp3",0.1));
    list.push_back(make_pair("ZLMeeNp4",0.1));
    list.push_back(make_pair("ZLMeeNp5",0.1));
    list.push_back(make_pair("ZeebbNp0",0.1));
    list.push_back(make_pair("ZeebbNp1",0.1));
    list.push_back(make_pair("ZeebbNp2",0.1));
    list.push_back(make_pair("ZeebbNp3",0.1));
    list.push_back(make_pair("ZeeccNp0",0.1));
    list.push_back(make_pair("ZeeccNp1",0.1));
    list.push_back(make_pair("ZeeccNp2",0.1));
    list.push_back(make_pair("ZeeccNp3",0.1));
  }
  
  if(sample.Contains("z_pythia")){         
    list.push_back(make_pair("ZLMmumuNp0",0.1));
    list.push_back(make_pair("ZLMmumuNp1",0.1));
    list.push_back(make_pair("ZLMmumuNp2",0.1));
    list.push_back(make_pair("ZLMmumuNp3",0.1));
    list.push_back(make_pair("ZLMmumuNp4",0.1));
    list.push_back(make_pair("ZLMmumuNp5",0.1));    
    list.push_back(make_pair("ZtautauLMNp0",0.1));
    list.push_back(make_pair("ZtautauLMNp1",0.1));
    list.push_back(make_pair("ZtautauLMNp2",0.1));
    list.push_back(make_pair("ZtautauLMNp3",0.1));
    list.push_back(make_pair("ZtautauLMNp4",0.1));
    list.push_back(make_pair("ZtautauLMNp5",0.1));    
    list.push_back(make_pair("ZLMeeNp0",0.1));
    list.push_back(make_pair("ZLMeeNp1",0.1));
    list.push_back(make_pair("ZLMeeNp2",0.1));
    list.push_back(make_pair("ZLMeeNp3",0.1));
    list.push_back(make_pair("ZLMeeNp4",0.1));
    list.push_back(make_pair("ZLMeeNp5",0.1));
    
    list.push_back(make_pair("PythiaZtautaubbNp0",0.1));
    list.push_back(make_pair("PythiaZtautaubbNp1",0.1));
    list.push_back(make_pair("PythiaZtautaubbNp2",0.1));
    list.push_back(make_pair("PythiaZtautaubbNp3",0.1));
    list.push_back(make_pair("PythiaZtautauccNp0",0.1));
    list.push_back(make_pair("PythiaZtautaiccNp1",0.1));
    list.push_back(make_pair("PythiaZtautauccNp2",0.1));
    list.push_back(make_pair("PythiaZtautauccNp3",0.1));
      
    list.push_back(make_pair("PythiaZmumuNp0",0.1));
    list.push_back(make_pair("PythiaZmumuNp1",0.1));
    list.push_back(make_pair("PythiaZmumuNp2",0.1));
    list.push_back(make_pair("PythiaZmumuNp3",0.1));
    list.push_back(make_pair("PythiaZmumuNp4",0.1));
    list.push_back(make_pair("PythiaZmumuNp5",0.1));

    list.push_back(make_pair("PythiaZtautauNp0",0.1));
    list.push_back(make_pair("PythiaZtautauNp1",0.1));
    list.push_back(make_pair("PythiaZtautauNp2",0.1));
    list.push_back(make_pair("PythiaZtautauNp3",0.1));
    list.push_back(make_pair("PythiaZtautauNp4",0.1));
    list.push_back(make_pair("PythiaZtautauNp5",0.1));
    list.push_back(make_pair("PythiaZmumubbNp0",0.1));
    list.push_back(make_pair("PythiaZmumubbNp1",0.1));
    list.push_back(make_pair("PythiaZmumubbNp2",0.1));
    list.push_back(make_pair("PythiaZmumubbNp3",0.1));
    list.push_back(make_pair("PythiaZmumuccNp0",0.1));
    list.push_back(make_pair("PythiaZmumuccNp1",0.1));
    list.push_back(make_pair("PythiaZmumuccNp2",0.1));
    list.push_back(make_pair("PythiaZmumuccNp3",0.1));

    list.push_back(make_pair("PythiaZeeNp0",0.1));
    list.push_back(make_pair("PythiaZeeNp1",0.1));
    list.push_back(make_pair("PythiaZeeNp2",0.1));
    list.push_back(make_pair("PythiaZeeNp3",0.1));
    list.push_back(make_pair("PythiaZeeNp4",0.1));
    list.push_back(make_pair("PythiaZeeNp5",0.1));
    list.push_back(make_pair("PythiaZeebbNp0",0.1));
    list.push_back(make_pair("PythiaZeebbNp1",0.1));
    list.push_back(make_pair("PythiaZeebbNp2",0.1));
    list.push_back(make_pair("PythiaZeebbNp3",0.1));
    list.push_back(make_pair("PythiaZeeccNp0",0.1));
    list.push_back(make_pair("PythiaZeeccNp1",0.1));
    list.push_back(make_pair("PythiaZeeccNp2",0.1));
    list.push_back(make_pair("PythiaZeeccNp3",0.1));

  }
  
  if(list.size()==0) cout << "Error in making lists" << endl;
  
  return list;
}

void CheckSamples(int nsamples){
  if(nsamples==0) {
    cout << "No sample in this vector" << endl;
    exit(1);
  }
  return;
}




THStack* MakeStack(vector<pair<pair<vector<pair<TString,float> >, int >, TString > > sample, TString type, string name, float xmin, float xmax,map<TString, TH1*>& legmap , int rebin){
  
  string clonename = name;	
  THStack* stack = new THStack();
  
  bool debug(false);
  if(type.Contains("Nominal")) debug=true;

  TString fileloc = "";
  if(type.Contains("Nominal")) fileloc = mcloc;
  if(type.Contains("JESup")) fileloc = jes_up_mcloc;
  if(type.Contains("JESdown")) fileloc = jes_down_mcloc;
  if(type.Contains("JER")) fileloc = jer_mcloc;
  if(type.Contains("JVFup")) fileloc = jvf_up_mcloc;
  if(type.Contains("JVFdown")) fileloc = jvf_down_mcloc;

  if(type.Contains("FakeUp")) fileloc = mcloc;
  if(type.Contains("FakeDown")) fileloc = mcloc;

 
  TDirectory* origDir = gDirectory;

  float sum_integral=0.;
  for(vector<pair<pair<vector<pair<TString,float> >, int >, TString > >::iterator it = sample.begin() ; it!= sample.end(); it++){
	
    if(!type.Contains("Nominal")) {
      if(it->first.first.at(0).first.Contains("datadriven"))fileloc=mcloc;
    }    

    if(it->second.Contains("CF")){
      fileloc = chargeflip_loc;
    }
    else fileloc = mcloc;
    
    if(it->second.Contains("CF")&& type.Contains("CFUp")) fileloc = chargeflip_up_loc;
    if(it->second.Contains("CF")&& type.Contains("CFDown")) fileloc = chargeflip_down_loc;
    if(it->second.Contains("Prompt") && type.Contains("FakeUp")) fileloc = datadriven_up_loc;
    if(it->second.Contains("Prompt") && type.Contains("FakeDOwn")) fileloc = datadriven_down_loc;
  
    CheckSamples( it->first.first.size() );
    
    TFile* file =  TFile::Open((fileloc+"HvyNAnalysis." + it->first.first.at(0).first + ".NTUP_SMWZ.Reco.root").Data());
    
     
    gROOT->cd();
    TDirectory* tempDir = 0;
    int counter = 0;
    while (not tempDir) {
      std::stringstream dirname;
      dirname << "WRHNCommonLeptonFakes_%i" << counter;
      if (gROOT->GetDirectory((dirname.str()).c_str())) {
	++counter;
	continue;
      }      
      tempDir = gROOT->mkdir((dirname.str()).c_str());      
    }
    
    
    

    tempDir->cd();
    
    TH1* h_tmp = dynamic_cast<TH1*> ((file->Get(name.c_str()))->Clone(clonename.c_str()));
    
    CheckHist(h_tmp);
    
    if(debug)cout <<  it->second <<  "  contribution " << 1 << "/" << it->first.first.size()  << " is from HvyNAnalysis." << it->first.first.at(0).first << ".NTUP_SMWZ.Reco.root : Integral = " <<h_tmp->Integral()  << endl;
    
    
    for(unsigned int i=1; i < it->first.first.size(); i++){	    
      clonename+="A";
             
      origDir->cd();
      
      TFile* file_loop =  TFile::Open((fileloc+"HvyNAnalysis." + it->first.first.at(i).first + ".NTUP_SMWZ.Reco.root").Data());	    

      tempDir->cd();
      TH1* h_loop = dynamic_cast<TH1*> ((file_loop->Get(name.c_str()))->Clone(clonename.c_str()));	    	    	    
      CheckHist(h_loop);
      h_tmp->Add(h_loop);	  	    	    
      
      if(debug)cout <<  it->second <<  "  contribution " <<i+1 <<"/" << it->first.first.size()  << " is from HvyNAnalysis." << it->first.first.at(i).first << ".NTUP_SMWZ.Reco.root : Integral = " <<h_loop->Integral() << " sum integral = " << h_tmp->Integral()    << endl;
      file_loop->Close();
    }	  	  
    
    /// TH1* is now made. Now make pretty
    FixOverUnderFlows(h_tmp, xmax);	  
    ///Set colors
    h_tmp->SetFillColor(it->first.second);
    h_tmp->SetLineColor(it->first.second);	  
    
    
    if(!stack->GetHists()) {
      stack->SetName( (string("s_") + name).c_str() );
      stack->SetTitle( (string("s_") + name).c_str() );
      SetTitles(h_tmp, name);
                 
  
    }//stack empt   
    

    h_tmp->Rebin(rebin);
    SetErrors(h_tmp, it->first.first.at(0).second);
           
    
    stack->Add(h_tmp);
    sum_integral+=h_tmp->Integral();
    
    if(type.Contains("Nominal")) {
      legmap[it->second] = h_tmp;
    }
    
    file->Close();	  
    origDir->cd();
  }
  
  cout << type << " has integral = " << sum_integral << endl;
  
  return stack;
}


TH1* MakeStackUp(map<TString, TH1*> map_of_stacks, TString clonename){
  
  map<TString, TH1*>::iterator it =  map_of_stacks.find("Nominal");
  
  float norm=1;
  TH1* h_up = dynamic_cast<TH1*>(it->second->Clone(clonename.Data())); // copy of nominal
  
  for(int binx=1 ; binx < h_up->GetNbinsX()+1; binx++){
    float nom_content = h_up->GetBinContent(binx);
    float nom_error = h_up->GetBinError(binx);
    
    it= map_of_stacks.find("JESup");
    float jesup_content = it->second->GetBinContent(binx);
    
    it= map_of_stacks.find("JESdown");
    float jesdown_content = it->second->GetBinContent(binx);
    
    it= map_of_stacks.find("JER");
    float jer_content = it->second->GetBinContent(binx);
   
    it= map_of_stacks.find("JVFup");
    float jvfup_content = it->second->GetBinContent(binx);
    
    it= map_of_stacks.find("JVFdown");
    float jvfdown_content = it->second->GetBinContent(binx);
    

    float fakedown_content= nom_content;
    it= map_of_stacks.find("FakeDown");
    if(it!= map_of_stacks.end()){
      fakedown_content = it->second->GetBinContent(binx);
    }
    
    float fakeup_content =nom_content;
    it= map_of_stacks.find("FakeUp");
    if(it!= map_of_stacks.end()){
      fakeup_content = it->second->GetBinContent(binx);
    }

    
    float err_jesup = jesup_content  - nom_content;
    float err_jesdown = jesdown_content  - nom_content;
    float err_jer = jer_content  - nom_content;
    float err_jvfup = jvfup_content  - nom_content;
    float err_jvfdown = jvfdown_content  - nom_content;
    float err_fakedown = fakedown_content  - nom_content;
    float err_fakeup = fakeup_content  - nom_content;
    
    if(err_jesup < 0 ) err_jesup=0;
    if(err_jesdown < 0 ) err_jesdown=0;
    if(err_jer < 0 ) err_jer=0;
    if(err_jvfup < 0 ) err_jvfup=0;
    if(err_jvfdown < 0 ) err_jvfdown=0;
    if(err_fakedown < 0 ) err_fakedown=0;
    if(err_fakeup < 0 ) err_fakeup=0;
    
    
    float errup2 =  nom_error*nom_error  + err_jesup*err_jesup + err_jesdown*err_jesdown + err_jer*err_jer + err_jvfup*err_jvfup + err_jvfdown*err_jvfdown + err_fakedown* err_fakedown +  err_fakeup*err_fakeup ;
    
    float new_bin = nom_content + sqrt(errup2);
    
    /*cout << "List of errors = " << endl;
    cout << "Normalisation = " << nom_error << endl;
    cout << "JESup = " << err_jesup << endl;
    cout << "JESdown = " << err_jesdown << endl;
    cout << "JVFup = " << err_jvfup << endl;
    cout << "JVFdown = " << err_jvfdown << endl;
    cout << "JER = " << err_jer << endl;*/
    

    h_up->SetBinContent(binx,new_bin);
    
  }
  
  return  h_up;
  
}


TH1* MakeStackDown(map<TString, TH1*> map_of_stacks, TString clonename){
  
  map<TString, TH1*>::iterator it =  map_of_stacks.find("Nominal");
  
  float norm=1;
  TH1* h_down = dynamic_cast<TH1*>(it->second->Clone(clonename.Data())); // copy of nominal
  
  for(int binx=1 ; binx < h_down->GetNbinsX()+1; binx++){
    float nom_content = h_down->GetBinContent(binx);
    float nom_error = h_down->GetBinError(binx);
    
    it= map_of_stacks.find("JESup");
    float jesup_content = it->second->GetBinContent(binx);
    
    it= map_of_stacks.find("JESdown");
    float jesdown_content = it->second->GetBinContent(binx);
    
    it= map_of_stacks.find("JER");
    float jer_content = it->second->GetBinContent(binx);
   
    it= map_of_stacks.find("JVFup");
    float jvfup_content = it->second->GetBinContent(binx);
    
    it= map_of_stacks.find("JVFdown");
    float jvfdown_content = it->second->GetBinContent(binx);
    
    float fakedown_content= nom_content;
    it= map_of_stacks.find("FakeDown");
    if(it!= map_of_stacks.end()){
      fakedown_content = it->second->GetBinContent(binx);
    }
    
    float fakeup_content =nom_content;
    it= map_of_stacks.find("FakeUp");
    if(it!= map_of_stacks.end()){
      fakeup_content = it->second->GetBinContent(binx);
    }
    

    float err_jesup = jesup_content  - nom_content;
    float err_jesdown = jesdown_content  - nom_content;
    float err_jer = jer_content  - nom_content;
    float err_jvfup = jvfup_content  - nom_content;
    float err_jvfdown = jvfdown_content  - nom_content;
    float err_fakedown = fakedown_content  - nom_content;
    float err_fakeup = fakeup_content  - nom_content;
    
    
    if(err_jesup > 0 ) err_jesup=0;
    if(err_jesdown > 0 ) err_jesdown=0;
    if(err_jer > 0 ) err_jer=0;
    if(err_jvfup > 0 ) err_jvfup=0;
    if(err_jvfdown > 0 ) err_jvfdown=0;
    if(err_fakedown > 0 ) err_fakedown=0;
    if(err_fakeup > 0 ) err_fakeup=0;
    
    
    //// nom_error = stat err + normalisation error, set previously on nom hist
    float errdown2 =  nom_error*nom_error  + err_jesup*err_jesup + err_jesdown*err_jesdown + err_jer*err_jer + err_jvfup*err_jvfup + err_jvfdown*err_jvfdown + err_fakedown* err_fakedown +  err_fakeup*err_fakeup ;
    
    float new_bin = nom_content - sqrt(errdown2);
    
        
    h_down->SetBinContent(binx,new_bin);
    
  }
  
  return  h_down;


}


TH1* MakeSumHist(THStack* thestack){
  
  TH1* hsum=0;  
  TList* list = thestack->GetHists();
  TIter it(list, true);
  TObject* obj=0;
  while( (obj = it.Next()) ) {
    TH1* h = dynamic_cast<TH1*>(obj);
    if(!hsum) hsum = (TH1*)h->Clone( (string(h->GetName()) + "_sum").c_str() );
    else {
      hsum->Add(h, 1.0);
    }
  }//hist loop
  
  return hsum;
}


void SetErrors(TH1* hist, float normerr){

  
  for(int binx =1; binx < hist->GetNbinsX()+1; binx++){
    float newbinerr = hist->GetBinError(binx)*hist->GetBinError(binx) + hist->GetBinContent(binx)*hist->GetBinContent(binx)*normerr*normerr;
    hist->SetBinError(binx, sqrt(newbinerr));
  }
  
  return;

}



void SetTitles(TH1* hist, string name){
  
  string xtitle ="";
  string ytitle ="Entries";

  float binedge_up = hist->GetBinLowEdge(2);
  float binedge_down = hist->GetBinLowEdge(1);
  
  float width = binedge_up - binedge_down;
  
  std::ostringstream str_width;
  str_width<< width;

  if(HistInGev(name)) ytitle = "Entries " +str_width.str() + " / GeV";
  
  if(name.find("MET")!=string::npos)xtitle="E^{miss}_{T} [GeV]"; 

  if(name.find("mu_eta")!=string::npos)xtitle="Muon #eta";
  if(name.find("mu_pt")!=string::npos)xtitle="Muon p_{T} [GeV]";
  if(name.find("mu1_pt")!=string::npos)xtitle="Lead p_{T} [GeV]";
  if(name.find("mu2_pt")!=string::npos)xtitle="Second p_{T} [GeV]";
  if(name.find("mu3_pt")!=string::npos)xtitle="Third p_{T} [GeV]";


  if(name.find("el_eta")!=string::npos)xtitle="Electron #eta";
  if(name.find("el_pt")!=string::npos)xtitle="Electron p_{T} [GeV]";
  if(name.find("el1_pt")!=string::npos)xtitle="Lead p_{T} [GeV]";
  if(name.find("el2_pt")!=string::npos)xtitle="Second p_{T} [GeV]";
  if(name.find("el3_pt")!=string::npos)xtitle="Third p_{T} [GeV]";
  
  if(name.find("leaddimuma")!=string::npos)xtitle="m(#mu#mu) [GeV]";
  if(name.find("leaddielma")!=string::npos)xtitle="m(ee) [GeV]";
  if(name.find("leademuma")!=string::npos)xtitle="m(e#mu) [GeV]";
  
  if(name.find("jet_eta")!=string::npos)xtitle="jet #eta";
  if(name.find("1jet_eta")!=string::npos)xtitle="Leading jet #eta";
  if(name.find("2jet_eta")!=string::npos)xtitle="2^{nd} Leading jet #eta";
  if(name.find("njet")!=string::npos)xtitle="Number of jets";

  if(name.find("muall")!=string::npos)xtitle="m(#mu#mu#mu(#mu)) [GeV]";
  


  hist->GetXaxis()->SetTitle(xtitle.c_str());
  hist->GetYaxis()->SetTitle(ytitle.c_str());

  return;
}


bool HistInGev(string name){
  
  bool ingev=false;
  if(name.find("pt")!=string::npos)ingev=true;
  if(name.find("mass")!=string::npos)ingev=true;
  
  return ingev;

}


float  GetMaximum(TH1* h_data, TH1* h_up, bool ylog, string name){

  float yscale= 1.4;
  if(ylog) yscale = 100000.;
  
  cout << name << endl;
  if(name.find("eta")!=string::npos) yscale*=1.5;
  if(name.find("MET")!=string::npos) yscale*=1.5;
  if(name.find("charge")!=string::npos) yscale*=2.5;
  
  float max_data = h_data->GetMaximum()*yscale;
  float max_bkg = h_up->GetMaximum()*yscale;

  
  if(max_data > max_bkg) return max_data;
  else return max_bkg;
  
  return -1000.;
}



float GetTotal(TString cut, vector<pair<TString,float> > samples){
  
  float total(0.);
  for(vector<pair<TString,float> >::iterator it = samples.begin(); it!=samples.end(); it++){
    total += GetIntegral(cut,(*it).first,"MC");
  }
  
  return total;    
}

float GetTotalCF(TString cut, vector<pair<TString,float> > samples){
  
  float total(0.);
  for(vector<pair<TString,float> >::iterator it = samples.begin(); it!=samples.end(); it++){
    total += GetIntegral(cut,(*it).first,"CF");
  }
  
  return total;    
}


float GetStatError2(TString cut, vector<pair<TString,float> > samples){  
  float err = GetStatError(cut,samples);
  err = err*err;
  return err;
}

float GetStatError(TString cut, vector<pair<TString,float> > samples){  

  TString path  = "/afs/hep.man.ac.uk/d/atlas-neutrino_6/2013/Analysis_pro14/MC/";
  
  if(samples.at(0).first.Contains("Z")){
    if(!samples.at(0).first.Contains("p"))path  = "/afs/hep.man.ac.uk/d/atlas-neutrino_6/2013/Analysis_pro14/CF/";      
  }
  TFile* f0 =  TFile::Open((path+"HvyNAnalysis." + samples.at(0).first + ".NTUP_SMWZ.Reco.root").Data());  
  TH1* h_tmp = dynamic_cast<TH1*> ((f0->Get(cut.Data()))->Clone());
  float stat_error(-99999.);

  for(unsigned int i=1; i < samples.size(); i++){
    
    
    TFile* f =  TFile::Open((path+"HvyNAnalysis." + samples.at(i).first + ".NTUP_SMWZ.Reco.root").Data());
    TH1* h = dynamic_cast<TH1*> ((f->Get(cut.Data()))->Clone());
    h_tmp->Add(h);
    f->Close();
    if(i == (samples.size()- 1)){
      stat_error = Error(h_tmp);
    }
  }

  if(samples.size()==1) stat_error = Error(h_tmp);
  
  f0->Close();
  return stat_error;
  
}


float GetStatErrorCF2(TString cut, vector<pair<TString,float> > samples){  
  float err = GetStatErrorCF(cut,samples);
  err = err*err;
  return err;
}

float GetStatErrorCF(TString cut, vector<pair<TString,float> > samples){  

  TString path  = "/afs/hep.man.ac.uk/d/atlas-neutrino_6/2013/Analysis_pro14/CF/";
  
  if(!samples.at(0).first.Contains("p"))path  = "/afs/hep.man.ac.uk/d/atlas-neutrino_6/2013/Analysis_pro14/CF/";      

  TFile* f0 =  TFile::Open((path+"HvyNAnalysis." + samples.at(0).first + ".NTUP_SMWZ.Reco.root").Data());  
  TH1* h_tmp = dynamic_cast<TH1*> ((f0->Get(cut.Data()))->Clone());
  float stat_error(-99999.);

  for(unsigned int i=1; i < samples.size(); i++){
    
    
    TFile* f =  TFile::Open((path+"HvyNAnalysis." + samples.at(i).first + ".NTUP_SMWZ.Reco.root").Data());
    TH1* h = dynamic_cast<TH1*> ((f->Get(cut.Data()))->Clone());
    h_tmp->Add(h);
    f->Close();
    if(i == (samples.size()- 1)){
      stat_error = Error(h_tmp);
    }
  }

  if(samples.size()==1) stat_error = Error(h_tmp);
  
  f0->Close();
  return stat_error;
  
}




float GetIntegral(TString cut, TString isample, TString type){

  TString path  = "/afs/hep.man.ac.uk/d/atlas-neutrino_6/2013/Analysis_pro14/"+ type + "/";
  
  TFile* f =  TFile::Open((path+"HvyNAnalysis." + isample + ".NTUP_SMWZ.Reco.root").Data());  
  
  
  if(!((f->Get(cut.Data())))){
    cout << "Histogram " << cut << " in "  << (path+"HvyNAnalysis." + isample + ".NTUP_SMWZ.Reco.root") << " not found" << endl;
    exit(0);
  }

  TH1* h = dynamic_cast<TH1*> ((f->Get(cut.Data())->Clone()));
  
  
  if(!h) {
    cout << "Histogram " << cut << " in "  << (path+"HvyNAnalysis." + isample + ".NTUP_SMWZ.Reco.root") << " not found" << endl;
    exit(1);
  }
  
  float integral = h->Integral();
 
  
  if(!h) {
    f->Close();
    cout << "Systematic file does not exist. Setting this error to zero" << endl;
    type = "MC";
    path  = "/afs/hep.man.ac.uk/d/atlas-neutrino_6/2013/Analysis_pro14/"+ type + "/";

    //TFile* f0 =  TFile::Open_tmp = new TFile((path+"HvyNAnalysis." + isample + ".NTUP_SMWZ.Reco.root").Data());
    TFile* f_tmp =  TFile::Open((path+"HvyNAnalysis." + isample + ".NTUP_SMWZ.Reco.root").Data());
    TH1* h_tmp = dynamic_cast<TH1*> ((f_tmp->Get(cut.Data())->Clone()));
    integral = h_tmp->Integral();
    f_tmp->Close();
    return integral;
  }
  

  f->Close();

  return integral;
  
}

float GetError(TString cut, TString isample, TString type){
  
  TString path  = "/afs/hep.man.ac.uk/d/atlas-neutrino_6/2013/Analysis_pro14/"+ type + "/";
    
  TFile* f =  TFile::Open((path+"HvyNAnalysis." + isample + ".NTUP_SMWZ.Reco.root").Data());
  TH1* h = dynamic_cast<TH1*> ((f->Get(cut.Data())->Clone()));
  cout << h << endl;
  
  if(!h) {
    cout << "Histogram " << cut << " in "  << (path+"HvyNAnalysis." + isample + ".NTUP_SMWZ.Reco.root") << " not found" << endl;
    exit(1);
  }
  
  float err = Error(h);
  
  f->Close();

  return err;
  
}


float GetNormErr(TString cut, vector<pair<TString,float> > samples){
  
  float norm_err(0.);
  int i=0;
  for( vector<pair<TString,float> >::iterator it = samples.begin(); it!=samples.end(); it++, i++){
    norm_err += GetIntegral(cut,it->first,"MC")* it->second*GetIntegral(cut,it->first,"MC")* it->second;
  }
  
  return sqrt(norm_err);
}

float GetNormErr2(TString cut,  vector<pair<TString,float> > samples){

  float err = GetNormErr(cut,samples);
  err = err*err;
  return err;
  
}



float GetErr2(TString cut, vector<pair<TString,float> > samples, TString err_type,TString var){
  
  float err = GetErr(cut,samples,err_type,var);
  err = err*err;
  return err;

}

float GetErr(TString cut, vector<pair<TString,float> > samples, TString err_type,TString var){

  float total(0.);
  float total_witherr(0.);
  
  int i=0;
  for(vector<pair<TString,float> >::iterator it = samples.begin(); it!=samples.end(); it++, i++){
    total += GetIntegral(cut,it->first,("MC/"));
    total_witherr += GetIntegral(cut,it->first,("MC_" + err_type));
  }
  
  
  float err=  total - total_witherr;      
  

  if(err_type.Contains("MM")){    
    if((var.Contains("UP")||var.Contains("Up"))) {
      if(( ( total - total_witherr)< 0.)) return fabs(err);
      else return total*0.1;
    }
    if((var.Contains("DOWN")||var.Contains("Down")) && ( ( total - total_witherr > 0.))) return err;
    else return total*0.1;  
  }
  
  if((var.Contains("UP")||var.Contains("Up"))) {
    if(( ( total - total_witherr)< 0.)) return fabs(err);
    else return 0.;
  }
  if((var.Contains("DOWN")||var.Contains("Down"))){
    if( ( total - total_witherr > 0.)) return err;
    else return 0.;  
  }

    return err;

}

float GetErrCF2(TString cut, vector<pair<TString,float> > samples, TString err_type,TString var){
  
  float err = GetErrCF(cut,samples,err_type,var);
  err = err*err;
  return err;

}



float GetErrCF(TString cut, vector<pair<TString,float> > samples, TString err_type,TString var){

  float total(0.);
  float total_witherr(0.);
  
  int i=0;
  for(vector<pair<TString,float> >::iterator it = samples.begin(); it!=samples.end(); it++, i++){
    total += GetIntegral(cut,it->first,("CF/"));
    total_witherr += GetIntegral(cut,it->first,(err_type));
  }
  
  
  float err=  total - total_witherr;      
  

  if(err_type.Contains("MM")){    
    if((var.Contains("UP")||var.Contains("Up"))) {
      if(( ( total - total_witherr)< 0.)) return fabs(err);
      else return total*0.1;
    }
    if((var.Contains("DOWN")||var.Contains("Down")) && ( ( total - total_witherr > 0.))) return err;
    else return total*0.1;  
  }
  
  if((var.Contains("UP")||var.Contains("Up"))) {
    if(( ( total - total_witherr)< 0.)) return fabs(err);
    else return 0.;
  }
  if((var.Contains("DOWN")||var.Contains("Down"))){
    if( ( total - total_witherr > 0.)) return err;
    else return 0.;  
  }

    return err;

}



float GetSystPercent(TString cut, TString syst, pair<vector<pair<TString,float> >,TString > samples ){

  return ( 100.*(GetSyst(cut, syst,samples )/ Calculate(cut,"Normal",samples)));
}



float GetSyst(TString cut, TString syst, pair<vector<pair<TString,float> >,TString > samples ){
  

  if(syst.Contains("Stat"))return GetStatError(cut,samples.first) ;    
  if(syst.Contains("Normalisation")) return GetNormErr(cut,samples.first);
  if(syst.Contains("JESup"))return GetErr(cut,samples.first,"JESup","");
  if(syst.Contains("JESdown"))return GetErr(cut,samples.first,"JESdown","");
  if(syst.Contains("JVFdown"))return GetErr(cut,samples.first,"JVFdown","");
  if(syst.Contains("JVFup"))return GetErr(cut,samples.first,"JVFup","");
  if(syst.Contains("JER"))return GetErr(cut,samples.first,"JER","");
  if(syst.Contains("TRIGup"))return GetErr(cut,samples.first,"TRIGup","");
  if(syst.Contains("TRIGdown"))return GetErr(cut,samples.first,"TRIGdown","");
  if(syst.Contains("MSup"))return GetErr(cut,samples.first,"MSup","");
  if(syst.Contains("MSdown"))return GetErr(cut,samples.first,"MSdown","");	
  if(syst.Contains("IDup"))return GetErr(cut,samples.first,"IDup","");
  if(syst.Contains("IDdown"))return GetErr(cut,samples.first,"IDdown","");	
  	
  if(syst.Contains("TOTAL"))return sqrt(  GetStatError2(cut,samples.first)+
					  GetNormErr2(cut,samples.first)+
					  GetErr2(cut,samples.first,"JESup","")+
					  GetErr2(cut,samples.first,"JESdown","")+
					  GetErr2(cut,samples.first,"JVFup","")+
					  GetErr2(cut,samples.first,"JVFdown","")+
					  GetErr2(cut,samples.first,"JER",""));
  
  return -9999.;
}


float Calculate(TString cut, TString variance, pair<vector<pair<TString,float> >,TString > samples ){
  
  
  if(samples.second.Contains("NonPrompt")){
    if(variance.Contains("Normal"))  return GetTotal(cut,samples.first) ;  
    if(variance.Contains("StatErr")) return GetStatError(cut,samples.first) ;  
    if(variance.Contains("Up")) return sqrt(GetErr2(cut,samples.first,"MMDown",variance)+GetErr2(cut,samples.first,"MMUp",variance));
    if(variance.Contains("Down")) return sqrt(GetErr2(cut,samples.first,"MMDown",variance)+GetErr2(cut,samples.first,"MMUp",variance) );       
  }
  


  if(samples.second.Contains("CF")){

    if(variance.Contains("Normal"))  return GetTotalCF(cut,samples.first) ;
    if(variance.Contains("StatErr")) return GetStatErrorCF(cut,samples.first) ;  
    cout << "2" << endl;
    if(variance.Contains("Up"))  return sqrt(GetErrCF2(cut,samples.first,"CF_UP/",variance)+GetErrCF2(cut,samples.first,"CF_UP/",variance));
    cout << "3" << endl;
    if(variance.Contains("Down"))  return sqrt(GetErrCF2(cut,samples.first,"CF_DOWN/",variance)+GetErrCF2(cut,samples.first,"CF_DOWN/",variance) );       

    cout << "END" << endl;
  }
  
  
  
  if(variance.Contains("Up") || variance.Contains("UP")||variance.Contains("Down") || variance.Contains("DOWN")  ){
    bool debug =false; 
    if(debug){
      cout << "Variance = " << variance << endl;
      cout << "Normalisation =" <<  GetNormErr(cut,samples.first) << endl;
      cout << "JESUp = " <<  GetErr(cut,samples.first,"JESup",variance) << endl;
      cout << "JESDown = " <<  GetErr(cut,samples.first,"JESdown",variance) << endl;
      cout << "JVFup = " <<  GetErr(cut,samples.first,"JVFup",variance) << endl;
      cout << "JVFdown = " <<  GetErr(cut,samples.first,"JVFdown",variance) << endl;
    }

    return fabs(sqrt( (GetNormErr2(cut,samples.first)
		       +  GetErr2(cut,samples.first,"JESup",variance) 
		       +  GetErr2(cut,samples.first,"JESdown",variance) 
		       +  GetErr2(cut,samples.first,"JVFup",variance) 
		       +  GetErr2(cut,samples.first,"JVFdown",variance) 
		       +  GetErr2(cut,samples.first,"JER",variance))));
    
  }
  
  if(variance.Contains("Normal")) return GetTotal(cut,samples.first) ;    
  
  if(variance.Contains("StatErr")) return GetStatError(cut,samples.first) ;    
    
  return -999999.;

}




float Error(TH1* h){
  double err ;
  double integral = h->IntegralAndError(0,h->GetNbinsX(),err,"");
  
  //  cout << "Integral of histogram " << h->GetName() << " =  " << integral << endl;
  return err;

}
