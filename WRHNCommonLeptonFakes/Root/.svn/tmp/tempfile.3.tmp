// STL include(s):                                                                                                                                                       
#include <stdexcept>
#include <sstream>
#include <iostream>


// ROOT include(s):                                                                                                                                                                
#include "TFile.h"
#include "TSystem.h"
#include "TROOT.h"
#include "TRandom.h"
#include "TDirectory.h"
#include "TLorentzVector.h"
#include "TH2.h"
#include "TEfficiency.h"

/// local includes
#include "WRHNCommonLeptonFakes/WRHNCommonLeptonFakes.h"

using namespace std;



TDirectory* WRHNCommonLeptonFakes::getTemporaryDirectory(void) const
{
  //                                                                                                                                                                                
  // Create a unique directory in memory to hold the histograms:                                                                                                                      //                                                                                                                                                                                 
  gROOT->cd();
  TDirectory* tempDir = 0;
  int counter = 0;
  while (not tempDir) {
    // First, let's find a directory name that doesn't exist yet:                                                                                                                    
    std::stringstream dirname;
    dirname << "WRHNCommonLeptonFakes_%i" << counter;
    if (gROOT->GetDirectory((dirname.str()).c_str())) {
      ++counter;
      continue;
    }
    // Let's try to make this directory:                                                                                                                                             
    tempDir = gROOT->mkdir((dirname.str()).c_str());

  }

  return tempDir;
}


void WRHNCommonLeptonFakes::InitialiseFake(){
  
  bool failedinitialisation=false;

  cout << "WRHNCommonLeptonFakes : Initializing" << endl;
  cout << "Accessing Fake Ntuple at " << path_to_root_files+"FakeRateDiLeptonWRHN.root" << endl;

  ///// 2012 Initialisation

  // Remember which TDirectory the system is in at the beginning of the method:                                                                                                      
  TDirectory* origDir = gDirectory;

  TFile* file_Muon_RealFake_Eff  = TFile::Open((path_to_root_files+"MuonRates/FakeRateDiLeptonWRHN.root").c_str());
  TFile* file_Muon_RealFake_OLDEff  = TFile::Open((path_to_root_files+"MuonRates/FakeRateDiLeptonWRHN_run1.root").c_str());
  TFile* file_Muon_RealFake_HSTEff = TFile::Open((path_to_root_files+"MuonRates/FakeRateDiLeptonWRHN_HST.root").c_str());
  TFile* file_Electron_Fake_Eff = TFile::Open((path_to_root_files+"ElectronRates_kirill/elfake.root").c_str());
  TFile* file_Electron_Real_Eff= TFile::Open((path_to_root_files+"ElectronRates_kirill/elrealeff.root").c_str());				       
  //// Lous files

  TFile* file_Electron_Fake_Lou_nominal_primary =  TFile::Open((path_to_root_files+"ElectronRates_lou/FakeRatePlots.MCSub.Nominal.Primary.root").c_str());
  TFile* file_Electron_Fake_Lou_nominal_secondary  = TFile::Open((path_to_root_files+"ElectronRates_lou/FakeRatePlots.MCSub.Nominal.Secondary.root").c_str());
  TFile* file_Electron_Fake_Lou_nominal_both =   TFile::Open((path_to_root_files+"ElectronRates_lou/FakeRatePlots.MCSub.Nominal.Both.root").c_str());
  TFile* file_Electron_Fake_Lou_nominal_either   = TFile::Open((path_to_root_files+"ElectronRates_lou/FakeRatePlots.MCSub.Nominal.Either.root").c_str());

  TFile* file_Electron_Fake_Lou_fakedown_both   = TFile::Open((path_to_root_files+"ElectronRates_lou/FakeRatePlots.MCSub.FakeDown.Both.root").c_str());
  TFile* file_Electron_Fake_Lou_fakedown_either   = TFile::Open((path_to_root_files+"ElectronRates_lou/FakeRatePlots.MCSub.FakeDown.Either.root").c_str());
  TFile* file_Electron_Fake_Lou_fakedown_primary   = TFile::Open((path_to_root_files+"ElectronRates_lou/FakeRatePlots.MCSub.FakeDown.Primary.root").c_str());
  TFile* file_Electron_Fake_Lou_fakedown_secondary   = TFile::Open((path_to_root_files+"ElectronRates_lou/FakeRatePlots.MCSub.FakeDown.Secondary.root").c_str());

  TFile* file_Electron_Fake_Lou_realdown_both =  TFile::Open((path_to_root_files+"ElectronRates_lou/FakeRatePlots.MCSub.RealDown.Both.root").c_str());
  TFile* file_Electron_Fake_Lou_realdown_either   = TFile::Open((path_to_root_files+"ElectronRates_lou/FakeRatePlots.MCSub.RealDown.Either.root").c_str());
  TFile* file_Electron_Fake_Lou_realdown_primary   = TFile::Open((path_to_root_files+"ElectronRates_lou/FakeRatePlots.MCSub.RealDown.Primary.root").c_str());	
  TFile* file_Electron_Fake_Lou_realdown_secondary   = TFile::Open((path_to_root_files+"ElectronRates_lou/FakeRatePlots.MCSub.RealDown.Secondary.root").c_str());	
  
  TFile* file_Electron_Fake_Lou_fakeup_both =  TFile::Open((path_to_root_files+"ElectronRates_lou/FakeRatePlots.MCSub.FakeUp.Both.root").c_str());
  TFile* file_Electron_Fake_Lou_fakeup_either =   TFile::Open((path_to_root_files+"ElectronRates_lou/FakeRatePlots.MCSub.FakeUp.Either.root").c_str());	
  TFile* file_Electron_Fake_Lou_fakeup_primary  = TFile::Open((path_to_root_files+"ElectronRates_lou/FakeRatePlots.MCSub.FakeUp.Primary.root").c_str());	  
  TFile* file_Electron_Fake_Lou_fakeup_secondary  = TFile::Open((path_to_root_files+"ElectronRates_lou/FakeRatePlots.MCSub.FakeUp.Secondary.root").c_str()); 
  
  TFile* file_Electron_Fake_Lou_realup_both  = TFile::Open((path_to_root_files+"ElectronRates_lou/FakeRatePlots.MCSub.RealUp.Both.root").c_str());	
  TFile* file_Electron_Fake_Lou_realup_either  = TFile::Open((path_to_root_files+"ElectronRates_lou/FakeRatePlots.MCSub.RealUp.Either.root").c_str());
  TFile* file_Electron_Fake_Lou_realup_primary  = TFile::Open((path_to_root_files+"ElectronRates_lou/FakeRatePlots.MCSub.RealUp.Primary.root").c_str());
  TFile* file_Electron_Fake_Lou_realup_secondary  = TFile::Open((path_to_root_files+"ElectronRates_lou/FakeRatePlots.MCSub.RealUp.Secondary.root").c_str());				       
  
  CheckFile(file_Muon_RealFake_Eff);
  CheckFile(file_Electron_Fake_Eff);
  CheckFile(file_Electron_Real_Eff);
  CheckFile(file_Electron_Fake_Lou_nominal_primary);	    
  CheckFile(file_Electron_Fake_Lou_nominal_secondary);	    
  CheckFile(file_Electron_Fake_Lou_nominal_both);	    
  CheckFile(file_Electron_Fake_Lou_nominal_either);	    
  CheckFile(file_Electron_Fake_Lou_fakeup_primary);	    
  CheckFile(file_Electron_Fake_Lou_fakeup_secondary);	    
  CheckFile(file_Electron_Fake_Lou_fakeup_both);	    
  CheckFile(file_Electron_Fake_Lou_fakeup_either);
  CheckFile(file_Electron_Fake_Lou_fakedown_primary);	    
  CheckFile(file_Electron_Fake_Lou_fakedown_secondary);	    
  CheckFile(file_Electron_Fake_Lou_fakedown_both);	    
  CheckFile(file_Electron_Fake_Lou_fakedown_either);
  CheckFile(file_Electron_Fake_Lou_realup_primary);	    
  CheckFile(file_Electron_Fake_Lou_realup_secondary);	    
  CheckFile(file_Electron_Fake_Lou_realup_both);	    
  CheckFile(file_Electron_Fake_Lou_realup_either);
  CheckFile(file_Electron_Fake_Lou_realdown_primary);	    
  CheckFile(file_Electron_Fake_Lou_realdown_secondary);	    
  CheckFile(file_Electron_Fake_Lou_realdown_both);	    
  CheckFile(file_Electron_Fake_Lou_realdown_either);


  

  //// Adding 2012 histograms to map
  
  
  // Create a unique directory in memory to hold the histograms:                                                                                                                     
  TDirectory* tempDir = getTemporaryDirectory();
  tempDir->cd();
  
  //// Efficiency for mumu channel
  
  
  _2DEfficiencyMap["real_eff_ptetajet0"] = dynamic_cast<TH2*>((file_Muon_RealFake_Eff->Get("Efficiency_zmasstight_pteta_jet0"))->Clone());
  _2DEfficiencyMap["real_eff_ptetajet1"] = dynamic_cast<TH2*>((file_Muon_RealFake_Eff->Get("Efficiency_zmasstight_pteta_jet1"))->Clone());
  _2DEfficiencyMap["real_eff_ptetajet23"] = dynamic_cast<TH2*>((file_Muon_RealFake_Eff->Get("Efficiency_zmasstight_pteta_jet23"))->Clone());
  _2DEfficiencyMap["real_eff_ptetajet4"] = dynamic_cast<TH2*>((file_Muon_RealFake_Eff->Get("Efficiency_zmasstight_pteta_jet4"))->Clone());

  _2DEfficiencyMap["real_eff_ptetajet0_up"] = dynamic_cast<TH2*>((file_Muon_RealFake_Eff->Get("Efficiency_zmasstight_pteta_jet0_Rup"))->Clone());
  _2DEfficiencyMap["real_eff_ptetajet1_up"] = dynamic_cast<TH2*>((file_Muon_RealFake_Eff->Get("Efficiency_zmasstight_pteta_jet1_Rup"))->Clone());
  _2DEfficiencyMap["real_eff_ptetajet23_up"] = dynamic_cast<TH2*>((file_Muon_RealFake_Eff->Get("Efficiency_zmasstight_pteta_jet23_Rup"))->Clone());
  _2DEfficiencyMap["real_eff_ptetajet4_up"] = dynamic_cast<TH2*>((file_Muon_RealFake_Eff->Get("Efficiency_zmasstight_pteta_jet4_Rup"))->Clone());

  _2DEfficiencyMap["real_eff_ptetajet0_down"] = dynamic_cast<TH2*>((file_Muon_RealFake_Eff->Get("Efficiency_zmasstight_pteta_jet0_Rdown"))->Clone());
  _2DEfficiencyMap["real_eff_ptetajet1_down"] = dynamic_cast<TH2*>((file_Muon_RealFake_Eff->Get("Efficiency_zmasstight_pteta_jet1_Rdown"))->Clone());
  _2DEfficiencyMap["real_eff_ptetajet23_down"] = dynamic_cast<TH2*>((file_Muon_RealFake_Eff->Get("Efficiency_zmasstight_pteta_jet23_Rdown"))->Clone());
  _2DEfficiencyMap["real_eff_ptetajet4_down"] = dynamic_cast<TH2*>((file_Muon_RealFake_Eff->Get("Efficiency_zmasstight_pteta_jet4_Rdown"))->Clone());

  
  /// Efficiency for muons in emu channel (has trigger isolation in loose sample
  _2DEfficiencyMap["real_eff_trigiso_ptetajet0"] = dynamic_cast<TH2*>((file_Muon_RealFake_Eff->Get("Efficiency_trigiso_pteta_jet0"))->Clone());
  _2DEfficiencyMap["real_eff_trigiso_ptetajet1"] = dynamic_cast<TH2*>((file_Muon_RealFake_Eff->Get("Efficiency_trigiso_pteta_jet1"))->Clone());
  _2DEfficiencyMap["real_eff_trigiso_ptetajet23"] = dynamic_cast<TH2*>((file_Muon_RealFake_Eff->Get("Efficiency_trigiso_pteta_jet23"))->Clone());
  _2DEfficiencyMap["real_eff_trigiso_ptetajet4"] = dynamic_cast<TH2*>((file_Muon_RealFake_Eff->Get("Efficiency_trigiso_pteta_jet4"))->Clone());



  /// Efficiency for electrons (kirills histograms) in ee of emu channel
  _2DEfficiencyMap["real_eff_el_fail_ptetajet0"] = dynamic_cast<TH2*>((file_Electron_Real_Eff->Get("h_EtaPtrate_RE_trigFAIL_2d_njeq0_e24vhimedium1ORe60medium1"))->Clone());
  _2DEfficiencyMap["real_eff_el_pass_ptetajet0"] = dynamic_cast<TH2*>((file_Electron_Real_Eff->Get("h_EtaPtrate_RE_trigPASS_2d_njeq0_e24vhimedium1ORe60medium1"))->Clone());
  _2DEfficiencyMap["real_eff_el_fail_ptetajet1"] = dynamic_cast<TH2*>((file_Electron_Real_Eff->Get("h_EtaPtrate_RE_trigFAIL_2d_njge1_e24vhimedium1ORe60medium1"))->Clone());
  _2DEfficiencyMap["real_eff_el_pass_ptetajet1"] = dynamic_cast<TH2*>((file_Electron_Real_Eff->Get("h_EtaPtrate_RE_trigPASS_2d_njge1_e24vhimedium1ORe60medium1"))->Clone());


  
  /// HST plots
  _2DEfficiencyMapHST["real_eff_ptetajet0"] = dynamic_cast<TH2*>((file_Muon_RealFake_HSTEff->Get("Efficiency_zmasstight_pteta_jet0"))->Clone());
  _2DEfficiencyMapHST["real_eff_ptetajet1"] = dynamic_cast<TH2*>((file_Muon_RealFake_HSTEff->Get("Efficiency_zmasstight_pteta_jet1"))->Clone());
  _2DEfficiencyMapHST["real_eff_ptetajet23"] = dynamic_cast<TH2*>((file_Muon_RealFake_HSTEff->Get("Efficiency_zmasstight_pteta_jet23"))->Clone());
  _2DEfficiencyMapHST["real_eff_ptetajet4"] = dynamic_cast<TH2*>((file_Muon_RealFake_HSTEff->Get("Efficiency_zmasstight_pteta_jet4"))->Clone());
  
  _2DEfficiencyMapHST["real_eff_ptetajet0_HSTup"] = dynamic_cast<TH2*>((file_Muon_RealFake_HSTEff->Get("Efficiency_zmasstight_pteta_jet0_HSTup"))->Clone());
  _2DEfficiencyMapHST["real_eff_ptetajet1_HSTup"] = dynamic_cast<TH2*>((file_Muon_RealFake_HSTEff->Get("Efficiency_zmasstight_pteta_jet1_HSTup"))->Clone());
  _2DEfficiencyMapHST["real_eff_ptetajet23_HSTup"] = dynamic_cast<TH2*>((file_Muon_RealFake_HSTEff->Get("Efficiency_zmasstight_pteta_jet23_HSTup"))->Clone());
  _2DEfficiencyMapHST["real_eff_ptetajet4_HSTup"] = dynamic_cast<TH2*>((file_Muon_RealFake_HSTEff->Get("Efficiency_zmasstight_pteta_jet4_HSTup"))->Clone());
  
  _2DEfficiencyMapHST["real_eff_ptetajet0_HSTdown"] = dynamic_cast<TH2*>((file_Muon_RealFake_HSTEff->Get("Efficiency_zmasstight_pteta_jet0_HSTdown"))->Clone());
  _2DEfficiencyMapHST["real_eff_ptetajet1_HSTdown"] = dynamic_cast<TH2*>((file_Muon_RealFake_HSTEff->Get("Efficiency_zmasstight_pteta_jet1_HSTdown"))->Clone());
  _2DEfficiencyMapHST["real_eff_ptetajet23_HSTdown"] = dynamic_cast<TH2*>((file_Muon_RealFake_HSTEff->Get("Efficiency_zmasstight_pteta_jet23_HSTdown"))->Clone());
  _2DEfficiencyMapHST["real_eff_ptetajet4_HSTdown"] = dynamic_cast<TH2*>((file_Muon_RealFake_HSTEff->Get("Efficiency_zmasstight_pteta_jet4_HSTdown"))->Clone());
  

  //// Adding 2012 fake rate hists
  
  /// Adding muon fake histograms to map
  regions.clear();
  regions.push_back("2mud0sigUB5_tight");
  //regions.push_back("2mud0sigUB5_tight_trigiso");
 
  //// 2-Dimensional
  for(unsigned int reg=0; reg< regions.size(); reg++){
    _2DEfficiencyMap[("h_" + regions[reg] + "HF_ptnjets").Data()] = dynamic_cast<TH2*>((file_Muon_RealFake_OLDEff->Get(("h_" + regions[reg] + "_HF_ptnjets").Data()))->Clone());
    _2DEfficiencyMap[("h_" + regions[reg] + "LF_ptnjets").Data()] = dynamic_cast<TH2*>((file_Muon_RealFake_OLDEff->Get(("h_" + regions[reg] + "_LF_ptnjets").Data()))->Clone());
        
  }


  map<TString,vector<pair<TFile*, TString> > > electronfakemap;
  vector<pair<TFile*, TString> > nomlist;
  nomlist.push_back(make_pair(file_Electron_Fake_Lou_nominal_both,"both"));
  nomlist.push_back(make_pair(file_Electron_Fake_Lou_nominal_either,"either"));
  nomlist.push_back(make_pair(file_Electron_Fake_Lou_nominal_secondary,"secondary"));
  nomlist.push_back(make_pair(file_Electron_Fake_Lou_nominal_primary,"primary"));
  
  vector<pair<TFile*, TString> > fakeuplist;
  fakeuplist.push_back(make_pair(file_Electron_Fake_Lou_fakeup_both,"both"));
  fakeuplist.push_back(make_pair(file_Electron_Fake_Lou_fakeup_either,"either"));
  fakeuplist.push_back(make_pair(file_Electron_Fake_Lou_fakeup_secondary,"secondary"));
  fakeuplist.push_back(make_pair(file_Electron_Fake_Lou_fakeup_primary,"primary"));

  vector<pair<TFile*, TString> > fakedownlist;
  fakedownlist.push_back(make_pair(file_Electron_Fake_Lou_fakedown_both,"both"));
  fakedownlist.push_back(make_pair(file_Electron_Fake_Lou_fakedown_either,"either"));
  fakedownlist.push_back(make_pair(file_Electron_Fake_Lou_fakedown_secondary,"secondary"));
  fakedownlist.push_back(make_pair(file_Electron_Fake_Lou_fakedown_primary,"primary"));

  vector<pair<TFile*, TString> > realuplist;
  realuplist.push_back(make_pair(file_Electron_Fake_Lou_realup_both,"both"));
  realuplist.push_back(make_pair(file_Electron_Fake_Lou_realup_either,"either"));
  realuplist.push_back(make_pair(file_Electron_Fake_Lou_realup_secondary,"secondary"));
  realuplist.push_back(make_pair(file_Electron_Fake_Lou_realup_primary,"primary"));

  vector<pair<TFile*, TString> > realdownlist;
  realdownlist.push_back(make_pair(file_Electron_Fake_Lou_realdown_both,"both"));
  realdownlist.push_back(make_pair(file_Electron_Fake_Lou_realdown_either,"either"));
  realdownlist.push_back(make_pair(file_Electron_Fake_Lou_realdown_secondary,"secondary"));
  realdownlist.push_back(make_pair(file_Electron_Fake_Lou_realdown_primary,"primary"));
  
  electronfakemap["nom"] = nomlist;
  electronfakemap["fakeup"] = fakeuplist;
  electronfakemap["fakedown"] = fakedownlist;


  
  for( map<TString,vector<pair<TFile*, TString> > >::iterator it = electronfakemap.begin(); it!= electronfakemap.end(); it++){
    
    for(unsigned int i=0 ; i < it->second.size() ; i++){
     
      _2DEfficiencyMap[( it->first + "_" + it->second.at(i).second + "_effAnalysisTrig_A_AL_TM_pT_eta").Data() ] = dynamic_cast<TH2*>((it->second.at(i).first->Get(("effAnalysisTrig_A_AL_TM_pT_eta")))->Clone());
      _2DEfficiencyMap[( it->first + "_" + it->second.at(i).second + "_effUnbiasedTrig_A_AL_TM_pT_eta").Data() ] = dynamic_cast<TH2*>((it->second.at(i).first->Get(("effUnbiasedTrig_A_AL_TM_pT_eta")))->Clone());
      _2DEfficiencyMap[( it->first + "_" + it->second.at(i).second + "_effLooseTrig_A_AL_TM_pT_eta").Data() ]   = dynamic_cast<TH2*>((it->second.at(i).first->Get(("effLooseTrig_A_AL_TM_pT_eta")))->Clone());
      
      _2DEfficiencyMap[( it->first + "_" + it->second.at(i).second + "_effAnalysisTrig_A_AL_TM_pT_eta_Conv").Data() ] = dynamic_cast<TH2*>((it->second.at(i).first->Get(("effAnalysisTrig_A_AL_TM_pT_eta_Conv")))->Clone());
      _2DEfficiencyMap[( it->first + "_" + it->second.at(i).second + "_effUnbiasedTrig_A_AL_TM_pT_eta_Conv").Data() ] = dynamic_cast<TH2*>((it->second.at(i).first->Get(("effUnbiasedTrig_A_AL_TM_pT_eta_Conv")))->Clone());
      _2DEfficiencyMap[( it->first + "_" + it->second.at(i).second + "_effLooseTrig_A_AL_TM_pT_eta_Conv").Data() ]   = dynamic_cast<TH2*>((it->second.at(i).first->Get(("effLooseTrig_A_AL_TM_pT_eta_Conv")))->Clone());
    
    }
  }
  

  map<TString,vector<pair<TFile*, TString> > > electronrealmap;
  electronrealmap["nom"] = nomlist;
  electronrealmap["realup"] = realuplist;
  electronrealmap["realdown"] = realdownlist;
  
  for(  map<TString,vector<pair<TFile*, TString> > >::iterator it = electronrealmap.begin(); it!= electronrealmap.end(); it++){
    
    for(unsigned int i=0 ; i < it->second.size() ; i++){
      
      _TEEfficiencyMap[( it->first + "_" + it->second.at(i).second + "_realEffAnalysisTrig_A_AL_TM_pT_eta").Data() ] = dynamic_cast<TEfficiency*>((it->second.at(i).first->Get(("realEffAnalysisTrig_A_AL_TM_pT_eta")))->Clone());
      _TEEfficiencyMap[( it->first + "_" + it->second.at(i).second + "_realEffLooseTrig_A_AL_TM_pT_eta").Data() ] = dynamic_cast<TEfficiency*>((it->second.at(i).first->Get(("realEffLooseTrig_A_AL_TM_pT_eta")))->Clone());
      _TEEfficiencyMap[( it->first + "_" + it->second.at(i).second + "_realEffUnbiasedTrig_A_AL_TM_pT_eta").Data() ] = dynamic_cast<TEfficiency*>((it->second.at(i).first->Get(("realEffUnbiasedTrig_A_AL_TM_pT_eta")))->Clone());
    }
  }
    
  //// 1-Dimensional
  for(unsigned int reg=0; reg< regions.size(); reg++){
    
    /// nominal
    _EfficiencyMap[("h_" + regions[reg] + "HF_pt_close").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_Eff->Get(("h_" + regions[reg] + "_HF_pt_close").Data()))->Clone());
    _EfficiencyMap[("h_" + regions[reg] + "LF_pt_close").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_Eff->Get(("h_" + regions[reg] + "_LF_pt_close").Data()))->Clone());
    
    _EfficiencyMap[("h_" + regions[reg] + "HF_pt_nj1_barrel").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_Eff->Get(("h_" + regions[reg] + "_HF_pt_nj1_barrel").Data()))->Clone());
    _EfficiencyMap[("h_" + regions[reg] + "HF_pt_gtnj1_barrel").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_Eff->Get(("h_" + regions[reg] + "_HF_pt_gtnj1_barrel").Data()))->Clone());
    _EfficiencyMap[("h_" + regions[reg] + "HF_pt_nj1_endcap").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_Eff->Get(("h_" + regions[reg] + "_HF_pt_nj1_endcap").Data()))->Clone());
    _EfficiencyMap[("h_" + regions[reg] + "HF_pt_gtnj1_endcap").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_Eff->Get(("h_" + regions[reg] + "_HF_pt_gtnj1_endcap").Data()))->Clone());
    
    _EfficiencyMap[("h_" + regions[reg] + "LF_pt_gtnj0_endcap").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_Eff->Get(("h_" + regions[reg] + "_LF_pt_gtnj0_endcap").Data()))->Clone());
    _EfficiencyMap[("h_" + regions[reg] + "LF_pt_gtnj0_barrel").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_Eff->Get(("h_" + regions[reg] + "_LF_pt_gtnj0_barrel").Data()))->Clone());
    
    /// + sigma
    
    _EfficiencyMap[("h_" + regions[reg] + "HF_pt_close_up").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_Eff->Get(("h_" + regions[reg] + "_HF_pt_close_Fup").Data()))->Clone());
    _EfficiencyMap[("h_" + regions[reg] + "LF_pt_close_up").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_Eff->Get(("h_" + regions[reg] + "_LF_pt_close_Fup").Data()))->Clone());

    _EfficiencyMap[("h_" + regions[reg] + "HF_pt_nj1_barrel_up").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_Eff->Get(("h_" + regions[reg] + "_HF_pt_nj1_barrel_Fup").Data()))->Clone());
    _EfficiencyMap[("h_" + regions[reg] + "HF_pt_gtnj1_barrel_up").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_Eff->Get(("h_" + regions[reg] + "_HF_pt_gtnj1_barrel_Fup").Data()))->Clone());
    _EfficiencyMap[("h_" + regions[reg] + "HF_pt_nj1_endcap_up").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_Eff->Get(("h_" + regions[reg] + "_HF_pt_nj1_endcap_Fup").Data()))->Clone());
    _EfficiencyMap[("h_" + regions[reg] + "HF_pt_gtnj1_endcap_up").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_Eff->Get(("h_" + regions[reg] + "_HF_pt_gtnj1_endcap_Fup").Data()))->Clone());

    _EfficiencyMap[("h_" + regions[reg] + "LF_pt_gtnj0_endcap_up").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_Eff->Get(("h_" + regions[reg] + "_LF_pt_gtnj0_endcap_Fup").Data()))->Clone());
    _EfficiencyMap[("h_" + regions[reg] + "LF_pt_gtnj0_barrel_up").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_Eff->Get(("h_" + regions[reg] + "_LF_pt_gtnj0_barrel_Fup").Data()))->Clone());


    //// - sigma
    _EfficiencyMap[("h_" + regions[reg] + "HF_pt_close_down").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_Eff->Get(("h_" + regions[reg] + "_HF_pt_close_Fdown").Data()))->Clone());
    _EfficiencyMap[("h_" + regions[reg] + "LF_pt_close_down").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_Eff->Get(("h_" + regions[reg] + "_LF_pt_close_Fdown").Data()))->Clone());

    _EfficiencyMap[("h_" + regions[reg] + "HF_pt_nj1_barrel_down").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_Eff->Get(("h_" + regions[reg] + "_HF_pt_nj1_barrel_Fdown").Data()))->Clone());
    _EfficiencyMap[("h_" + regions[reg] + "HF_pt_gtnj1_barrel_down").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_Eff->Get(("h_" + regions[reg] + "_HF_pt_gtnj1_barrel_Fdown").Data()))->Clone());
    _EfficiencyMap[("h_" + regions[reg] + "HF_pt_nj1_endcap_down").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_Eff->Get(("h_" + regions[reg] + "_HF_pt_nj1_endcap_Fdown").Data()))->Clone());
    _EfficiencyMap[("h_" + regions[reg] + "HF_pt_gtnj1_endcap_down").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_Eff->Get(("h_" + regions[reg] + "_HF_pt_gtnj1_endcap_Fdown").Data()))->Clone());

    _EfficiencyMap[("h_" + regions[reg] + "LF_pt_gtnj0_endcap_down").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_Eff->Get(("h_" + regions[reg] + "_LF_pt_gtnj0_endcap_Fdown").Data()))->Clone());
    _EfficiencyMap[("h_" + regions[reg] + "LF_pt_gtnj0_barrel_down").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_Eff->Get(("h_" + regions[reg] + "_LF_pt_gtnj0_barrel_Fdown").Data()))->Clone());

    
    
    ///// HST
    _EfficiencyMapHST[("h_" + regions[reg] + "HF_pt_close").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_HSTEff->Get(("h_" + regions[reg] + "_HF_pt_close").Data()))->Clone());
    _EfficiencyMapHST[("h_" + regions[reg] + "LF_pt_close").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_HSTEff->Get(("h_" + regions[reg] + "_LF_pt_close").Data()))->Clone());

    _EfficiencyMapHST[("h_" + regions[reg] + "HF_pt_nj1_barrel").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_HSTEff->Get(("h_" + regions[reg] + "_HF_pt_nj1_barrel").Data()))->Clone());
    _EfficiencyMapHST[("h_" + regions[reg] + "HF_pt_gtnj1_barrel").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_HSTEff->Get(("h_" + regions[reg] + "_HF_pt_gtnj1_barrel").Data()))->Clone());
    _EfficiencyMapHST[("h_" + regions[reg] + "HF_pt_nj1_endcap").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_HSTEff->Get(("h_" + regions[reg] + "_HF_pt_nj1_endcap").Data()))->Clone());
    _EfficiencyMapHST[("h_" + regions[reg] + "HF_pt_gtnj1_endcap").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_HSTEff->Get(("h_" + regions[reg] + "_HF_pt_gtnj1_endcap").Data()))->Clone());

    _EfficiencyMapHST[("h_" + regions[reg] + "LF_pt_gtnj0_endcap").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_HSTEff->Get(("h_" + regions[reg] + "_LF_pt_gtnj0_endcap").Data()))->Clone());
    _EfficiencyMapHST[("h_" + regions[reg] + "LF_pt_gtnj0_barrel").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_HSTEff->Get(("h_" + regions[reg] + "_LF_pt_gtnj0_barrel").Data()))->Clone());

    ///// HST up
    _EfficiencyMapHST[("h_" + regions[reg] + "HF_pt_close_HSTup").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_HSTEff->Get(("h_" + regions[reg] + "_HF_pt_close_HSTup").Data()))->Clone());
    _EfficiencyMapHST[("h_" + regions[reg] + "LF_pt_close_HSTup").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_HSTEff->Get(("h_" + regions[reg] + "_LF_pt_close_HSTup").Data()))->Clone());

    _EfficiencyMapHST[("h_" + regions[reg] + "HF_pt_nj1_barrel_HSTup").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_HSTEff->Get(("h_" + regions[reg] + "_HF_pt_nj1_barrel_HSTup").Data()))->Clone());
    _EfficiencyMapHST[("h_" + regions[reg] + "HF_pt_gtnj1_barrel_HSTup").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_HSTEff->Get(("h_" + regions[reg] + "_HF_pt_gtnj1_barrel_HSTup").Data()))->Clone());
    _EfficiencyMapHST[("h_" + regions[reg] + "HF_pt_nj1_endcap_HSTup").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_HSTEff->Get(("h_" + regions[reg] + "_HF_pt_nj1_endcap_HSTup").Data()))->Clone());
    _EfficiencyMapHST[("h_" + regions[reg] + "HF_pt_gtnj1_endcap_HSTup").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_HSTEff->Get(("h_" + regions[reg] + "_HF_pt_gtnj1_endcap_HSTup").Data()))->Clone());

    _EfficiencyMapHST[("h_" + regions[reg] + "LF_pt_gtnj0_endcap_HSTup").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_HSTEff->Get(("h_" + regions[reg] + "_LF_pt_gtnj0_endcap_HSTup").Data()))->Clone());
    _EfficiencyMapHST[("h_" + regions[reg] + "LF_pt_gtnj0_barrel_HSTup").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_HSTEff->Get(("h_" + regions[reg] + "_LF_pt_gtnj0_barrel_HSTup").Data()))->Clone());

    ///// HST down
    _EfficiencyMapHST[("h_" + regions[reg] + "HF_pt_close_HSTdown").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_HSTEff->Get(("h_" + regions[reg] + "_HF_pt_close_HSTdown").Data()))->Clone());
    _EfficiencyMapHST[("h_" + regions[reg] + "LF_pt_close_HSTdown").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_HSTEff->Get(("h_" + regions[reg] + "_LF_pt_close_HSTdown").Data()))->Clone());

    _EfficiencyMapHST[("h_" + regions[reg] + "HF_pt_nj1_barrel_HSTdown").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_HSTEff->Get(("h_" + regions[reg] + "_HF_pt_nj1_barrel_HSTdown").Data()))->Clone());
    _EfficiencyMapHST[("h_" + regions[reg] + "HF_pt_gtnj1_barrel_HSTdown").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_HSTEff->Get(("h_" + regions[reg] + "_HF_pt_gtnj1_barrel_HSTdown").Data()))->Clone());
    _EfficiencyMapHST[("h_" + regions[reg] + "HF_pt_nj1_endcap_HSTdown").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_HSTEff->Get(("h_" + regions[reg] + "_HF_pt_nj1_endcap_HSTdown").Data()))->Clone());
    _EfficiencyMapHST[("h_" + regions[reg] + "HF_pt_gtnj1_endcap_HSTdown").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_HSTEff->Get(("h_" + regions[reg] + "_HF_pt_gtnj1_endcap_HSTdown").Data()))->Clone());
    
    _EfficiencyMapHST[("h_" + regions[reg] + "LF_pt_gtnj0_endcap_HSTdown").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_HSTEff->Get(("h_" + regions[reg] + "_LF_pt_gtnj0_endcap_HSTdown").Data()))->Clone());
    _EfficiencyMapHST[("h_" + regions[reg] + "LF_pt_gtnj0_barrel_HSTdown").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_HSTEff->Get(("h_" + regions[reg] + "_LF_pt_gtnj0_barrel_HSTdown").Data()))->Clone());
    
  }
  
  /// Adding electron fake histograms to map
  
  // Trigger pass
  _EfficiencyMap[("h_pt_trigpass_conv")] = dynamic_cast<TH1*>(dynamic_cast<TH1*>(file_Electron_Fake_Eff->Get(("h_Ptrate_FR_trigPASS_sub_conv_e24vhimedium1ORe60medium1")))->Clone());
  _EfficiencyMap[("h_pt_trigpass_nonconv_barrel")] = dynamic_cast<TH1*>(dynamic_cast<TH1*>(file_Electron_Fake_Eff->Get(("h_Ptrate_FR_trigPASS_sub_nonconvANDbarrel_e24vhimedium1ORe60medium1")))->Clone());
  _EfficiencyMap[("h_pt_trigpass_nonconv_endcap")] = dynamic_cast<TH1*>(dynamic_cast<TH1*>(file_Electron_Fake_Eff->Get(("h_Ptrate_FR_trigPASS_sub_nonconvANDendcap_e24vhimedium1ORe60medium1")))->Clone());
  

  
  // Trigger fail
  _EfficiencyMap[("h_pt_trigfail_conv")] = dynamic_cast<TH1*>((file_Electron_Fake_Eff->Get(("h_Ptrate_FR_trigFAIL_sub_conv_e24vhimedium1ORe60medium1")))->Clone());
  _EfficiencyMap[("h_pt_trigfail_nonconv_barrel")] = dynamic_cast<TH1*>((file_Electron_Fake_Eff->Get(("h_Ptrate_FR_trigFAIL_sub_nonconvANDbarrel_e24vhimedium1ORe60medium1")))->Clone());
  _EfficiencyMap[("h_pt_trigfail_nonconv_endcap")] = dynamic_cast<TH1*>((file_Electron_Fake_Eff->Get(("h_Ptrate_FR_trigFAIL_sub_nonconvANDendcap_e24vhimedium1ORe60medium1")))->Clone());
  
  
  for(map<TString, TH1*>::iterator mit = _EfficiencyMap.begin(); mit != _EfficiencyMap.end(); mit++){
    if(!mit->second){
      cout << "Failed " << mit->first << endl;
      failedinitialisation=true;
    }
  }

  for(map<TString, TH1*>::iterator mit = _EfficiencyMapHST.begin(); mit != _EfficiencyMapHST.end(); mit++){
    if(!mit->second){
      cout << "Failed " << mit->first << endl;
      failedinitialisation=true;
    }
  }

  for(map<TString, TH2*>::iterator mit = _2DEfficiencyMap.begin(); mit != _2DEfficiencyMap.end(); mit++){
    if(!mit->second){
      cout << "Failed " << mit->first << endl;
      failedinitialisation=true;
    }
  }
  
  for(map<TString, TEfficiency*>::iterator mit = _TEEfficiencyMap.begin(); mit != _TEEfficiencyMap.end(); mit++){
    if(!mit->second){
      cout << "Failed " << mit->first << endl;
      failedinitialisation=true;
    }
  }
  
  if(failedinitialisation){
    cout << "Not all histograms could be initialised, this is a bug so am exiting" << endl;
  }
  else {
    
    cout << "WRHNCommonLeptonFakes : Initialsation was successful " << endl;
    cout << "WRHNCommonLeptonFakes : Default setting in MeV" <<  endl;
    cout << "WRHNCommonLeptonFakes : To Use GeV set third argument of constructor true" << endl;
  }
  SystMap.clear();
  for(vector<TString>::iterator rit = regions.begin(); rit!=regions.end() ; rit++){
    SystMap[*rit]=0.;
  }

  // Now we can close the file:                                                                                                                                                      
  file_Muon_RealFake_Eff->Close();
  file_Muon_RealFake_HSTEff->Close();
  file_Electron_Fake_Eff->Close();
  file_Electron_Real_Eff->Close();
  file_Electron_Fake_Lou_nominal_primary->Close();
  file_Electron_Fake_Lou_nominal_secondary->Close();
  file_Electron_Fake_Lou_nominal_both->Close();
  file_Electron_Fake_Lou_nominal_either->Close();
  file_Electron_Fake_Lou_realup_primary->Close();
  file_Electron_Fake_Lou_realup_secondary->Close();
  file_Electron_Fake_Lou_realup_both->Close();
  file_Electron_Fake_Lou_realup_either->Close();
  file_Electron_Fake_Lou_realdown_primary->Close();
  file_Electron_Fake_Lou_realdown_secondary->Close();
  file_Electron_Fake_Lou_realdown_both->Close();
  file_Electron_Fake_Lou_realdown_either->Close();
  file_Electron_Fake_Lou_fakedown_primary->Close();
  file_Electron_Fake_Lou_fakedown_secondary->Close();
  file_Electron_Fake_Lou_fakedown_both->Close();
  file_Electron_Fake_Lou_fakedown_either->Close();
  file_Electron_Fake_Lou_fakeup_primary->Close();
  file_Electron_Fake_Lou_fakeup_secondary->Close();
  file_Electron_Fake_Lou_fakeup_both->Close();
  file_Electron_Fake_Lou_fakeup_either->Close();
    
  delete file_Muon_RealFake_Eff;
  delete file_Electron_Fake_Eff;
  delete file_Electron_Real_Eff;
  delete file_Muon_RealFake_HSTEff;
  delete file_Electron_Fake_Lou_nominal_primary;
  delete file_Electron_Fake_Lou_nominal_secondary;
  delete file_Electron_Fake_Lou_nominal_both;
  delete file_Electron_Fake_Lou_nominal_either;
  delete file_Electron_Fake_Lou_realup_primary;
  delete file_Electron_Fake_Lou_realup_secondary;
  delete file_Electron_Fake_Lou_realup_both;
  delete file_Electron_Fake_Lou_realup_either;
  delete file_Electron_Fake_Lou_realdown_primary;
  delete file_Electron_Fake_Lou_realdown_secondary;
  delete file_Electron_Fake_Lou_realdown_both;
  delete file_Electron_Fake_Lou_realdown_either;
  delete file_Electron_Fake_Lou_fakedown_primary;
  delete file_Electron_Fake_Lou_fakedown_secondary;
  delete file_Electron_Fake_Lou_fakedown_both;
  delete file_Electron_Fake_Lou_fakedown_either;
  delete file_Electron_Fake_Lou_fakeup_primary;
  delete file_Electron_Fake_Lou_fakeup_secondary;
  delete file_Electron_Fake_Lou_fakeup_both;
  delete file_Electron_Fake_Lou_fakeup_either;
    
  // Return to the directory we were in before the function call:                                                                                                                    
  origDir->cd();
  


  return;
}


/// Constructor
WRHNCommonLeptonFakes::WRHNCommonLeptonFakes(std::string path,bool usegev){

  path_to_root_files = path;
  useGeV = usegev;
  InitialiseFake();
  m_debug=false;
  NullTotals();
}


/// Destructor
WRHNCommonLeptonFakes::~WRHNCommonLeptonFakes() {
  closefile();   
  CutHists.clear();
}



void WRHNCommonLeptonFakes::ApplyFakeSystematic(int type){
 
  //  if(type==0)cout << "WRHNCommonLeptonFakes : Running in default mode f [no systematic applied] " << endl;
  //  if(type==1)cout << "WRHNCommonLeptonFakes : Applying systematic f + sigma" << endl;
  //  if(type==-1)cout << "WRHNCommonLeptonFakes : Applying systematic f - sigma" << endl;
  
  fsys=type;
}

void WRHNCommonLeptonFakes::ApplyRealSystematic(int type ){
  
  //if(type==0)cout << "WRHNCommonLeptonFakes : Running in default mode r [no systematic applied] " << endl;
  //if(type==1)cout << "WRHNCommonLeptonFakes : Applying systematic r + sigma " << endl;
  //if(type==-1)cout << "WRHNCommonLeptonFakes : Applying systematic r - sigma " << endl;
  
  rsys=type;
}




float  WRHNCommonLeptonFakes::get_dilepton_ee_eventweight(std::vector<TLorentzVector> electrons, std::vector<TLorentzVector> jets, bool _el1_conv, bool _el2_conv, bool _el1_primarytriggerpass, bool _el1_secondarytriggerpass, bool _el2_primarytriggerpass, bool _el2_secondarytriggerpass,bool isel1tight, bool isel2tight,bool inGeV, bool use_kirill){
  
  useGeV=inGeV;
  if(electrons.size()!=2) {
    cout << "DiLepton event weight requires 2 muons." << endl;
    return (0.);
  }
  

  float _el1_pt=electrons.at(0).Pt();
  float _el2_pt=electrons.at(1).Pt();

  //// vectors need to be ordered in pT
  if(_el1_pt < _el2_pt) return -100000000000.;

  
  float _el1_eta=electrons.at(0).Eta();
  float _el2_eta=electrons.at(1).Eta();

  int njets = jets.size();
  if(m_debug){
    cout << "WRHNCommonLeptonFakes::Event Summary (ee) " << endl;
    cout << "el1 pT = " << _el1_pt << endl;
    cout << "el2 pT = " << _el2_pt << endl;
  }
  if(!useGeV){    
    _el1_pt = _el1_pt/1000.;
    _el2_pt = _el2_pt/1000.;
  }
  
  //// Current electron histograms have pt max 200 (both lous and kirills)
  if(_el1_pt > 200.) _el1_pt = 199.;
  if(_el2_pt > 200.) _el2_pt = 199.;


  float fr1(0.),fr2(0.),r1(0.),r2(0.);  

  // can use either kirills or lous rates
  
  /// remove event if neither electron is matched to trigger
  if(!(_el1_primarytriggerpass || _el2_primarytriggerpass || _el1_secondarytriggerpass || _el2_secondarytriggerpass )) return 0.;
  
  if(use_kirill){
    bool  _el1_triggerpass = (_el1_primarytriggerpass || _el1_secondarytriggerpass);
    bool  _el2_triggerpass = (_el2_primarytriggerpass || _el2_secondarytriggerpass);
    r1 = getEfficiency_electron_kirill(rsys,_el1_pt,_el1_eta, njets, _el1_triggerpass);
    r2 = getEfficiency_electron_kirill(rsys,_el2_pt,_el2_eta, njets, _el2_triggerpass);
  }
  else{
    std::pair<float,float> reff_el = getEfficiency_electron_ee_lou(rsys, _el1_pt, _el2_pt, _el1_eta, _el2_eta,_el1_primarytriggerpass,_el1_secondarytriggerpass,_el2_primarytriggerpass,_el2_secondarytriggerpass);    
    r1 = reff_el.first;
    r2 = reff_el.second;    
  }
    
  if(use_kirill){
    bool  _el1_triggerpass = (_el1_primarytriggerpass || _el1_secondarytriggerpass);
    bool  _el2_triggerpass = (_el2_primarytriggerpass || _el2_secondarytriggerpass);
    fr1=getFakeRate_electrons_kirill(fsys,_el1_pt, _el1_eta, njets, _el1_triggerpass, _el1_conv);
    fr2=getFakeRate_electrons_kirill(fsys,_el2_pt, _el2_eta, njets, _el2_triggerpass, _el2_conv);
  }
  else{
    
    std::pair<float,float> fake_el = getFakeRate_electrons_ee_lou(fsys,  _el1_pt, _el2_pt, _el1_eta, _el2_eta,_el1_primarytriggerpass,_el1_secondarytriggerpass,_el2_primarytriggerpass,_el2_secondarytriggerpass,_el1_conv, _el2_conv);
    fr1 = fake_el.first;
    fr2 = fake_el.second;    
    
  }
  
  // Calculate event weight
  float ev_weight = CalculateDiLepMMWeight(r1,fr1,r2,fr2, isel1tight, isel2tight);
  
  
  if(fabs(ev_weight) > 2.|| ev_weight == 0.){
    cout << "\n ---------------------------------  "<< endl;
    cout << "WRHNCommonLeptonFakes::Event Summary (ee) " << endl;
    cout << "weight = " << ev_weight << endl;
    cout << "r1 = " << r1 << endl;
    cout << "r2 = " << r2 << endl;
    cout << "fr1 = " << fr1 << endl;    
    cout << "fr2 = " << fr2 << endl;

    cout << "lep1 (Tight)loose = " << isel1tight << endl;
    cout << "lep2 (Tight)loose = " << isel2tight << endl;

    cout << "njets = " << jets.size() << endl;
    cout << "el1 pT = " << _el1_pt << endl;
    cout << "el2 pT = " << _el2_pt << endl;
    cout << "el1 eta = " << _el1_eta << endl;
    cout << "el2 eta = " << _el2_eta << endl;

    cout << "el1 trigger = " << _el1_primarytriggerpass << " " << _el1_secondarytriggerpass << endl;
    cout << "el2 trigger = " << _el2_primarytriggerpass << " " << _el2_secondarytriggerpass << endl;
    cout << "el1 conv = " << _el1_conv << endl;
    cout << "el2 conv = " << _el2_conv << endl;             
  }

  return ev_weight;

}

float  WRHNCommonLeptonFakes::get_dilepton_emu_eventweight(std::vector<TLorentzVector> muons,  std::vector<TLorentzVector> electrons, std::vector<TLorentzVector> jets,bool ismutight, bool iseltight, bool is_muonHF,bool is_elconv, bool _el_primarytriggerpass, bool _el_secondarytriggerpass,bool _mu_triggerpass, bool inGeV, bool use_kirill){

  useGeV=inGeV;
 
  float _mu_pt=muons.at(0).Pt();
  float _mu_eta=muons.at(0).Eta();
  
  float _el_pt= electrons.at(0).Pt();
  float _el_eta= electrons.at(0).Eta();
  
  bool mujet_overlap=false;
  for(vector<TLorentzVector>::iterator it = jets.begin(); it!=jets.end();it++){
    if(muons.at(0).DeltaR(*it) < 0.4) mujet_overlap =true; 
  }
  
  int njets= jets.size();
  
  if(!useGeV){    
    _mu_pt = _mu_pt/1000.;
    _el_pt = _el_pt/1000.;
  }
  
  //// Current electron histograms have pt max 200
  if(_el_pt > 200.) _el_pt = 199.;
  
 
  float fr1(0.),fr2(0.),r1(0.),r2(0.);  

  bool  is_lep1_tight(false);
  bool  is_lep2_tight(false);
  
  /// Check pt ordering
  if(muons.at(0).Pt() > electrons.at(0).Pt()) {
    
    is_lep1_tight = ismutight;
    is_lep2_tight = iseltight;
    
    r1 = getEfficiency_muon(rsys,_mu_pt, _mu_eta, njets, "real_eff_trigiso");
    fr1= getFakeRate_muons(fsys,is_muonHF,_mu_pt, njets, _mu_eta, mujet_overlap,"2mud0sigUB5_tight_trigiso" );

    if(use_kirill){      
      bool  _el_triggerpass = (_el_primarytriggerpass || _el_secondarytriggerpass);
      r2 = getEfficiency_electron_kirill(rsys, _el_pt, _el_eta, njets,_el_triggerpass);
      fr2= getFakeRate_electrons_kirill(fsys,_el_pt,_el_eta, njets, _el_triggerpass, is_elconv);         
    }
    else{
      if(!(_el_primarytriggerpass ||  _el_secondarytriggerpass || _mu_triggerpass )) return 0.;
      r2 = getEfficiency_electron_emu_lou(rsys, _mu_pt, _el_pt, _el_eta,_mu_triggerpass,_el_primarytriggerpass,_el_secondarytriggerpass);
      fr2 =getFakeRate_electrons_emu_lou (fsys,  _mu_pt, _el_pt, _el_eta, _mu_triggerpass, _el_primarytriggerpass,_el_secondarytriggerpass,is_elconv);
    }        
  }
  else {

    is_lep1_tight = iseltight;
    is_lep2_tight = ismutight;

    r2 = getEfficiency_muon(rsys,_mu_pt, _mu_eta, njets, "real_eff_trigiso");
    fr2=getFakeRate_muons(fsys,is_muonHF,_mu_pt, njets, _mu_eta, mujet_overlap,"2mud0sigUB5_tight_trigiso" );

    if(use_kirill){      
      bool  _el_triggerpass = (_el_primarytriggerpass || _el_secondarytriggerpass);
      r1 = getEfficiency_electron_kirill(rsys, _el_pt, _el_eta, njets,_el_triggerpass);
      fr1= getFakeRate_electrons_kirill(fsys,_el_pt,_el_eta, njets, _el_triggerpass, is_elconv);         
    }
    else{
      if(!(_el_primarytriggerpass ||  _el_secondarytriggerpass || _mu_triggerpass )) return 0.;
      r1 = getEfficiency_electron_emu_lou(rsys, _mu_pt, _el_pt, _el_eta,_mu_triggerpass ,_el_primarytriggerpass,_el_secondarytriggerpass);
      fr1 =getFakeRate_electrons_emu_lou (fsys,  _mu_pt, _el_pt, _el_eta, _mu_triggerpass, _el_primarytriggerpass,_el_secondarytriggerpass,is_elconv);
    }          
  }
  
  
  
  if(double(CalculateDiLepMMWeight(r1,fr1,r2,fr2, ismutight, iseltight) ) != CalculateDiLepMMWeight(r1,fr1,r2,fr2, ismutight, iseltight)) {

    cout << "\n ---------------------------------------------------------------------- \n" << endl;
    cout << r1 << endl;
    cout << r2 << endl;
    cout << fr1 << endl;
    cout << fr2 << endl;
    cout << "mu pt = " << _mu_pt << endl;
    cout << "mu eta = " << _mu_eta << endl;
    cout << "njets = " << njets << endl;
    
    cout << "el pt = " << _el_pt   << endl;
    cout << "el eta = " << _el_eta  << endl;
  }
  
  if(fabs(CalculateDiLepMMWeight(r1,fr1,r2,fr2, ismutight, iseltight)) > 2. || CalculateDiLepMMWeight(r1,fr1,r2,fr2, ismutight, iseltight) == 0.){
    cout << "\n ---------------------------------  "<< endl;
    cout << "WRHNCommonLeptonFakes::Event Summary (emu) " << endl;
    cout << "weight = " <<CalculateDiLepMMWeight(r1,fr1,r2,fr2, ismutight, iseltight)    << endl;
    cout << "r1 = " << r1 << endl;
    cout << "r2 = " << r2 << endl;
    cout << "fr1 = " << fr1 << endl;
    cout << "fr2 = " << fr2 << endl;

    cout << "el pT = " << _el_pt << endl;
    cout << "mu pT = " << _mu_pt << endl;
    cout << "el eta = " << _el_eta << endl;
    cout << "mu eta = " << _mu_eta << endl;

    cout << "el trigger = " << _el_primarytriggerpass << " " << _el_secondarytriggerpass << endl;
    cout << "mu trigger = " << _mu_triggerpass << endl;
    
    cout << "el1 conv = " << is_elconv << endl;
    
    cout << "muon isHF = " << is_muonHF << endl;
    cout << "njets = " << njets << endl;
    cout<< "close muon to jet = " << mujet_overlap << endl;    

    cout << "mu (Tight)loose = " << ismutight << endl;
    cout << "el (Tight)loose = " << iseltight << endl;

  }
 
  
    // Calculate event weight  
  return CalculateDiLepMMWeight(r1,fr1,r2,fr2, ismutight, iseltight);

}


float  WRHNCommonLeptonFakes::get_dilepton_mm_eventweight( std::vector<TLorentzVector> muons, std::vector<TLorentzVector> jets,bool ismu1tight, bool ismu2tight,bool isHF1, bool isHF2,bool inGeV, bool oldrates){
  
  useGeV=inGeV;
  if(muons.size()!=2) {
    cout << "DiLepton event weight requires 2 muons." << endl;
    return (0.);
  }
  
  float _mu1_pt=muons.at(0).Pt();
  float _mu1_eta=muons.at(0).Eta();
  float _mu2_pt=muons.at(1).Pt();
  float _mu2_eta=muons.at(1).Eta();

  bool mu1jet_overlap=false;
  bool mu2jet_overlap=false;
  for(vector<TLorentzVector>::iterator it = jets.begin(); it!=jets.end();it++){
    if(muons.at(0).DeltaR(*it) < 0.4) mu1jet_overlap =true; 
    if(muons.at(1).DeltaR(*it) < 0.4) mu2jet_overlap =true; 
  }
   
  int njets= jets.size();

  if(!useGeV){    
    _mu1_pt = _mu1_pt/1000.;
    _mu2_pt = _mu2_pt/1000.;
  }

  
  float fr1(0.),fr2(0.),r1(0.),r2(0.);  
  /// Get real efficiencies (pt max 200 set in function) uses tight zwindow: rsys sets systematic (0/1/-1)
  r1 = getEfficiency_muon(rsys,_mu1_pt, _mu1_eta,njets, "real_eff");
  r2 = getEfficiency_muon(rsys,_mu2_pt, _mu2_eta,njets, "real_eff");
 

  /// if using new rates (with fits) 
  fr1=getFakeRate_muons(fsys,isHF1,_mu1_pt, njets, _mu1_eta, mu1jet_overlap,"2mud0sigUB5_tight");
  fr2=getFakeRate_muons(fsys,isHF2,_mu2_pt, njets, _mu2_eta, mu2jet_overlap,"2mud0sigUB5_tight");    
  
  if(oldrates){
    fr1=getFakeRate_muonsold(fsys,isHF1,_mu1_pt, njets, _mu1_eta, mu1jet_overlap,"2mud0sigUB5_tight");
    fr2=getFakeRate_muonsold(fsys,isHF2,_mu2_pt, njets, _mu2_eta, mu2jet_overlap,"2mud0sigUB5_tight");      
  }
  

  float ev_weight = CalculateDiLepMMWeight(r1,fr1,r2,fr2, ismu1tight, ismu2tight);

  if(fabs(ev_weight) > 2.|| ev_weight == 0.){
    cout << "\n ---------------------------------  "<< endl;
    cout << "WRHNCommonLeptonFakes::Event Summary (mm) " << endl;
    cout << "weight = " << ev_weight << endl;
    cout << "r1 = " << r1 << endl;
    cout << "r2 = " << r2 << endl;
    cout << "fr1 = " << fr1 << endl;    
    cout << "fr2 = " << fr2 << endl;

    cout << "mu1 (Tight)loose = " << ismu1tight << endl;
    cout << "mu2 (Tight)loose = " << ismu2tight << endl;

    cout << "njets = " << jets.size() << endl;
    cout << "mu1 pT = " << _mu1_pt << endl;
    cout << "mu2 pT = " << _mu2_pt << endl;
    cout << "mu1 eta = " << _mu1_eta << endl;
    cout << "mu2 eta = " << _mu2_eta << endl;

  }

  return ev_weight;


}


  



float WRHNCommonLeptonFakes::getEfficiency_electron_emu_lou(int sys, float muon_pt, float el_pt, float el_eta, bool muon_triggerpass, bool primarytrigger_el, bool secondarytrigger_el){
  
  
  float eff_real(-100000000000.);  
  map<TString,TEfficiency*>::const_iterator mapit;  
  
  bool el_leading(true);
  if(muon_pt > el_pt) el_leading = false;
  
  TString file_name = "nom_";
  if(sys ==1) file_name = "realup_";
  if(sys ==-1) file_name = "realdown_";
  
  
  TString trigger_type ="";
  TString rate_type ="";


  if(el_leading){
    bool lep1_pass = (primarytrigger_el || secondarytrigger_el);
    bool lep2_pass = (muon_triggerpass);
      
    if( lep1_pass &&  lep2_pass) {
      
      /// BOTH UNBIASED
      trigger_type ="both";
      rate_type = "Unbiased";
    }
    
    if(lep1_pass && !lep2_pass){    
      if(primarytrigger_el  && secondarytrigger_el)     trigger_type ="both";
      if(primarytrigger_el  && !secondarytrigger_el)     trigger_type ="primary";
      if(!primarytrigger_el  && secondarytrigger_el)     trigger_type ="secondary";
      rate_type = "Analysis";
    }
    
    if(!lep1_pass && lep2_pass){    
      
      trigger_type ="either";
      rate_type = "Loose";      
    }
    if(!lep1_pass && !lep2_pass) return 0.;
  }
  else{
    
    bool lep2_pass = (primarytrigger_el || secondarytrigger_el);
    bool lep1_pass = (muon_triggerpass);

    /// electron is lep2

    if( lep1_pass &&  lep2_pass) {
      
      /// BOTH UNBIASED
      trigger_type ="both";
      rate_type = "Unbiased";
    }
    
    if(lep1_pass && !lep2_pass){    
      trigger_type ="both";
      rate_type = "Unbiased";
    }
    
    if(!lep1_pass && lep2_pass){    
      
      if(primarytrigger_el  && secondarytrigger_el)     trigger_type ="both";
      if(primarytrigger_el  && !secondarytrigger_el)     trigger_type ="primary";
      if(!primarytrigger_el  && secondarytrigger_el)     trigger_type ="secondary";
      rate_type = "Analysis";
    }
    if(!lep1_pass && !lep2_pass) return 0.;
  }
  

  
  
  TString hist_name = file_name+ trigger_type +  "_realEff" + rate_type + "Trig_A_AL_TM_pT_eta";
  
  mapit = _TEEfficiencyMap.find(hist_name);
  
  if(mapit!=_TEEfficiencyMap.end()){
    
    int binx =  ((TH2*)(mapit->second->GetTotalHistogram()))->FindBin(el_pt,el_eta);  	
    eff_real =  mapit->second->GetEfficiency(binx);    
  }
  else NoHist(hist_name); 
  

  return eff_real;
  
}



pair<float,float> WRHNCommonLeptonFakes::getEfficiency_electron_ee_lou(int sys, float lep1_pt, float lep2_pt, float lep1_eta, float lep2_eta, bool primarytrigger_lep1,  bool secondarytrigger_lep1, bool primarytrigger_lep2, bool secondarytrigger_lep2){
  
  float eff_real1(-100000000000.);
  float eff_real2(-100000000000.);
  
  map<TString,TEfficiency*>::const_iterator mapit;  
  
  if(lep1_pt < lep2_pt) cout << "Check leading / sub-leading inputs for electrons in WRHNCommonLeptonFakes package" << endl;
  
  TString file_name = "nom_";
  if(sys ==1) file_name = "realup_";
  if(sys ==-1) file_name = "realdown_";
  
  
  bool lep1_pass = (primarytrigger_lep1 || secondarytrigger_lep1);
  bool lep2_pass = (primarytrigger_lep2 || secondarytrigger_lep2);

  TString trigger_type1 ="";
  TString rate_type1 ="";
  TString trigger_type2 ="";
  TString rate_type2 ="";
  if( lep1_pass &&  lep2_pass) {
    
    /// BOTH UNBIASED
    trigger_type1 ="both";
    rate_type1 = "Unbiased";
    
    trigger_type2 ="both";
    rate_type2 = "Unbiased";
  }
  
  if(lep1_pass && !lep2_pass){    
    if(primarytrigger_lep1  && secondarytrigger_lep1)     trigger_type1 ="both";
    if(primarytrigger_lep1  && !secondarytrigger_lep1)     trigger_type1 ="primary";
    if(!primarytrigger_lep1  && secondarytrigger_lep1)     trigger_type1 ="secondary";
    rate_type1 = "Analysis";

    trigger_type2 ="both";
    rate_type2 = "Unbiased";
  }

   
  if(!lep1_pass && lep2_pass){    

    trigger_type1 ="either";
    rate_type1 = "Loose";

    if(primarytrigger_lep2  && secondarytrigger_lep2)     trigger_type2 ="both";
    if(primarytrigger_lep2  && !secondarytrigger_lep2)     trigger_type2 ="primary";
    if(!primarytrigger_lep2  && secondarytrigger_lep2)     trigger_type2 ="secondary";
    rate_type2 = "Analysis";
  }
  
  if(!lep1_pass && !lep2_pass) return make_pair(0.,0.);
  

  TString hist_name1 = file_name+ trigger_type1 +  "_realEff" + rate_type1 + "Trig_A_AL_TM_pT_eta";
  TString hist_name2 = file_name+ trigger_type2 +  "_realEff" + rate_type2 + "Trig_A_AL_TM_pT_eta";

  
  mapit = _TEEfficiencyMap.find(hist_name1);
  
  if(mapit!=_TEEfficiencyMap.end()){
    int bin =  ((TH2*)(mapit->second->GetTotalHistogram()))->FindBin(lep1_pt,lep1_eta);  	
    eff_real1 =  mapit->second->GetEfficiency(bin);    
  }
  else NoHist(hist_name1); 
  
  mapit = _TEEfficiencyMap.find(hist_name2);
  
  if(mapit!=_TEEfficiencyMap.end()){
    int bin =  ((TH2*)(mapit->second->GetTotalHistogram()))->FindBin(lep2_pt,lep2_eta);  	
    eff_real2 =  mapit->second->GetEfficiency(bin);    
  }
  else NoHist(hist_name2); 
  
  return make_pair(eff_real1,eff_real2 );
  
  //*
  //  EE channel: assuming only non conversion electrons.
  //
  // electron 1 TRIGGER CONF			    electron 2  TRIGGER CONF			      ROOTFILE / histogram                        ROOTFILE / histogram
  //  
  //  %%%% BOTH MATCH: Unbiased/Unbiased %%%%
  //  ANY       				   ANY      					      effUnbiasedTrig_A_AL_TM_pT                  effUnbiasedTrig_A_AL_TM_pT
  //  
  //  %%% Leading matched, sub-leading unmatched: Pass/Unbiased %%%%
  //  EF_e60_medium1 &&  EF_e24vhi_medium1      NEITHER                                            Both.root/effAnalysisTrig_A_AL_TM_pT        effUnbiasedTrig_A_AL_TM_pT
  //  EF_e60_medium1 && !EF_e24vhi_medium1      NEITHER                                            Secondary.root/effAnalysisTrig_A_AL_TM_pT   effUnbianedTrig_A_AL_TM_pT  
  //  !EF_e60_medium1 &&  EF_e24vhi_medium1      NEITHER                                            Primary.root/effAnalysisTrig_A_AL_TM_pT     effUnbiasedTrig_A_AL_TM_pT
  //  
  //  
  //  %%% Leading unmatched, sub-leading matched: Fail/Pass %%%
  //  NEITHER                                    EF_e60_medium1 &&  EF_e24vhi_medium1               Either.root/effLooseTrig_A_AL_TM_pT         Both.root/effAnalysisTrig_A_AL_TM_pT
  //  NEITHER                                    EF_e60_medium1 && !EF_e24vhi_medium1               Either.root/effLooseTrig_A_AL_TM_pT         Secondary.root/effAnalysisTrig_A_AL_TM_pT
  // NEITHER                                   !EF_e60_medium1 &&  EF_e24vhi_medium1               Either.root/effLooseTrig_A_AL_TM_pT         Primary.root/effAnalysisTrig_A_AL_TM_pT
  //  
  //  %%%% BOTH FAIL %%%%
  //  Not including these events
  // 
  //
  // *////////////////////

  
}


float WRHNCommonLeptonFakes::getEfficiency_electron_kirill(int sys, float pt, float eta, int njet, bool passtrigger){

  map<TString,TH2*>::const_iterator mapit;  
    
  double eff_real(0.);  
 
  TString hist ="real_eff_el_";
  if(passtrigger) hist +="pass_ptetajet";
  else hist += "fail_ptetajet";
  
  if(njet==0 )hist += "0";
  else  hist += "1";
  
  mapit = _2DEfficiencyMap.find(hist);
  
  if(mapit!=_2DEfficiencyMap.end()){
    int binx=mapit->second->FindBin(pt,eta);  	
    eff_real =  mapit->second->GetBinContent(binx);    
  }
  else NoHist(hist); 
  
  //// INITIAL METHOD OF SYSTEMATICS
  if(sys==1) eff_real*=1.05;
  if(sys==-1) eff_real*=0.95;

  return eff_real;
  
}


float WRHNCommonLeptonFakes::getFakeRate_electrons_emu_lou(int sys, float muon_pt, float el_pt, float el_eta, bool muon_passtrigger, bool primarytrigger_el,  bool secondarytrigger_el, bool el_conv){

 float eff_fake(-100000000000.);
  
  map<TString,TH2*>::const_iterator mapit;  
  
  bool el_leading(true);
  if(muon_pt > el_pt) el_leading = false;
  
  TString file_name = "nom_";
  if(sys ==1) file_name = "fakeup_";
  if(sys ==-1) file_name = "fakedown_";
  
  
  TString trigger_type ="";
  TString rate_type ="";

  if(el_leading){
    bool lep1_pass = (primarytrigger_el || secondarytrigger_el);
    bool lep2_pass = (muon_passtrigger);
      
    if( lep1_pass &&  lep2_pass) {
      
      /// BOTH UNBIASED
      trigger_type ="both";
      rate_type = "Unbiased";
    }
    
    if(lep1_pass && !lep2_pass){    
      if(primarytrigger_el  && secondarytrigger_el)     trigger_type ="both";
      if(primarytrigger_el  && !secondarytrigger_el)     trigger_type ="primary";
      if(!primarytrigger_el  && secondarytrigger_el)     trigger_type ="secondary";
      rate_type = "Analysis";
    }
   
    if(!lep1_pass && lep2_pass){    
      
      trigger_type ="either";
      rate_type = "Loose";      
    }
  }
  else{
    
    bool lep2_pass = (primarytrigger_el || secondarytrigger_el);
    bool lep1_pass = (muon_passtrigger);

    /// electron is lep2

    if( lep1_pass &&  lep2_pass) {
      
      /// BOTH UNBIASED
      trigger_type ="both";
      rate_type = "Unbiased";
    }
    
    if(lep1_pass && !lep2_pass){    
      trigger_type ="both";
      rate_type = "Unbiased";
    }
    
    if(!lep1_pass && lep2_pass){    
      
      if(primarytrigger_el  && secondarytrigger_el)     trigger_type ="both";
      if(primarytrigger_el  && !secondarytrigger_el)     trigger_type ="primary";
      if(!primarytrigger_el  && secondarytrigger_el)     trigger_type ="secondary";
      rate_type = "Analysis";
    }
  }
  


  TString hist_name = file_name+ trigger_type +  "_eff" + rate_type + "Trig_A_AL_TM_pT_eta";  
  mapit = _2DEfficiencyMap.find(hist_name);
  
  if(mapit!=_2DEfficiencyMap.end()){
    int binx=mapit->second->FindBin(el_pt,el_eta);  	
    eff_fake =  mapit->second->GetBinContent(binx);    
    if(eff_fake > 0.7 || eff_fake==0. || eff_fake< 0.){
      int bin = binx-1;
      eff_fake =  mapit->second->GetBinContent(bin);      
      if(eff_fake > 0.7 || eff_fake==0. || eff_fake < 0.) bin = binx+1;
      eff_fake =  mapit->second->GetBinContent(bin);  
      if(eff_fake > 0.7 || eff_fake==0. || eff_fake < 0.) bin = binx-2;
      eff_fake =  mapit->second->GetBinContent(bin);       
      if(eff_fake > 0.7 || eff_fake==0. || eff_fake < 0.) bin = binx+2;
      eff_fake =  mapit->second->GetBinContent(bin);   
    }       
  }
  else NoHist(hist_name); 
  
  return eff_fake;
  

}


pair<float,float> WRHNCommonLeptonFakes::getFakeRate_electrons_ee_lou(int sys, float lep1_pt, float lep2_pt, float lep1_eta, float lep2_eta, bool primarytrigger_lep1,  bool secondarytrigger_lep1, bool primarytrigger_lep2, bool secondarytrigger_lep2, bool el1_conv, bool el2_conv){
  
  float eff_fake1(-100000000000.);
  float eff_fake2(-100000000000.);
  
  map<TString,TH2*>::const_iterator mapit;  
  
  if(lep1_pt < lep2_pt) cout << "Check leading / sub-leading inputs for electrons in WRHNCommonLeptonFakes package" << endl;
  
  TString file_name = "nom_";
  if(sys ==1) file_name = "fakeup_";
  if(sys ==-1) file_name = "fakedown_";
    
  bool lep1_pass = (primarytrigger_lep1 || secondarytrigger_lep1);
  bool lep2_pass = (primarytrigger_lep2 || secondarytrigger_lep2);

  TString trigger_type1 ="";
  TString rate_type1 ="";
  TString trigger_type2 ="";
  TString rate_type2 ="";
  if( lep1_pass &&  lep2_pass) {
    
    /// BOTH UNBIASED
    trigger_type1 ="both";
    rate_type1 = "Unbiased";
    
    trigger_type2 ="both";
    rate_type2 = "Unbiased";
  }
  
  if(lep1_pass && !lep2_pass){    
    // lepton 1
    if(primarytrigger_lep1  && secondarytrigger_lep1)     trigger_type1 ="both";
    if(primarytrigger_lep1  && !secondarytrigger_lep1)     trigger_type1 ="primary";
    if(!primarytrigger_lep1  && secondarytrigger_lep1)     trigger_type1 ="secondary";
    rate_type1 = "Analysis";
    
    // lepton 2
    trigger_type2 ="both";
    rate_type2 = "Unbiased";
  }

   
  if(!lep1_pass && lep2_pass){    
    // lepton 1
    trigger_type1 ="either";
    rate_type1 = "Loose";
    // lepton 2
    if(primarytrigger_lep2  && secondarytrigger_lep2)     trigger_type2 ="both";
    if(primarytrigger_lep2  && !secondarytrigger_lep2)     trigger_type2 ="primary";
    if(!primarytrigger_lep2  && secondarytrigger_lep2)     trigger_type2 ="secondary";
    rate_type2 = "Analysis";
  }

  if(!lep1_pass && !lep2_pass) return make_pair(0.,0.);

  TString hist_name1 = file_name+ trigger_type1 +  "_eff" + rate_type1 + "Trig_A_AL_TM_pT_eta";
  TString hist_name2 = file_name+ trigger_type2 +  "_eff" + rate_type2 + "Trig_A_AL_TM_pT_eta";
  
  if(el1_conv) hist_name1 += "_Conv";
  if(el2_conv) hist_name2 += "_Conv";
    
  mapit = _2DEfficiencyMap.find(hist_name1);
  
  if(mapit!=_2DEfficiencyMap.end()){
    int binx=mapit->second->FindBin(lep1_pt,lep1_eta);  	
    eff_fake1 =  mapit->second->GetBinContent(binx);    
    if(eff_fake1 > 0.7 || eff_fake1==0. || eff_fake1< 0.){
      int bin = binx-1;
      eff_fake1 =  mapit->second->GetBinContent(bin);      
      if(eff_fake1 > 0.7 || eff_fake1==0. || eff_fake1 < 0.) bin = binx+1;
      eff_fake1 =  mapit->second->GetBinContent(bin);  
      if(eff_fake1 > 0.7 || eff_fake1==0. || eff_fake1 < 0.) bin = binx-2;
      eff_fake1 =  mapit->second->GetBinContent(bin);       
      if(eff_fake1 > 0.7 || eff_fake1==0. || eff_fake1 < 0.) bin = binx+2;
      eff_fake1 =  mapit->second->GetBinContent(bin);   
    }       
  }
  else NoHist(hist_name1); 
  
	
  mapit = _2DEfficiencyMap.find(hist_name2);
  
  if(mapit!=_2DEfficiencyMap.end()){
    int binx=mapit->second->FindBin(lep2_pt,lep2_eta);  	
    eff_fake2 =  mapit->second->GetBinContent(binx);    

    if(eff_fake2 > 0.7 || eff_fake2==0. || eff_fake2< 0.){
      int bin = binx-1;
      eff_fake2 =  mapit->second->GetBinContent(bin);      
      if(eff_fake2 > 0.7 || eff_fake2==0. || eff_fake2 < 0.) bin = binx+1;
      eff_fake2 =  mapit->second->GetBinContent(bin);  
      if(eff_fake2 > 0.7 || eff_fake2==0. || eff_fake2 < 0.) bin = binx-2;
      eff_fake2 =  mapit->second->GetBinContent(bin);       
      if(eff_fake2 > 0.7 || eff_fake2==0. || eff_fake2 < 0.) bin = binx+2;
      eff_fake2 =  mapit->second->GetBinContent(bin);   
    }       
  }
  else NoHist(hist_name2); 


  if(eff_fake1 < 0. || eff_fake1 ==0. || eff_fake1 > 0.7) {
    
    cout << hist_name1 << endl;
    cout << eff_fake1 << endl;
    cout << "el1 pt = " << lep1_pt << endl;
    cout << "el1 eta = " << lep1_eta << endl;
    
    mapit = _2DEfficiencyMap.find(hist_name1);
    
    if(mapit!=_2DEfficiencyMap.end()){
      int binx=mapit->second->FindBin(lep1_pt,lep1_eta);  	
      cout <<   mapit->second->GetBinContent(binx+2) << endl;
      cout <<   mapit->second->GetBinContent(binx+1) << endl;
      cout <<   mapit->second->GetBinContent(binx) << endl;
      cout <<   mapit->second->GetBinContent(binx-1) << endl;
      cout <<   mapit->second->GetBinContent(binx-2) << endl;
    }
    std::getchar();
  }    
  if(eff_fake2 < 0. || eff_fake2 ==0. || eff_fake2 > 0.7) {
    cout << hist_name1 << endl;
    cout << eff_fake2 << endl;
    cout << "el2 pt = " << lep2_pt << endl;
    cout << "el2 eta = " << lep2_eta << endl;
    mapit = _2DEfficiencyMap.find(hist_name2);
    
    if(mapit!=_2DEfficiencyMap.end()){
      int binx=mapit->second->FindBin(lep2_pt,lep2_eta);  	
      cout <<   mapit->second->GetBinContent(binx+2) << endl;
      cout <<   mapit->second->GetBinContent(binx+1) << endl;
      cout <<   mapit->second->GetBinContent(binx) << endl;
      cout <<   mapit->second->GetBinContent(binx-1) << endl;
      cout <<   mapit->second->GetBinContent(binx-2) << endl;
    }

    std::getchar();
  }    



  return make_pair(eff_fake1,eff_fake2 );

}

float WRHNCommonLeptonFakes::getFakeRate_electrons_kirill(int sys, float pt, float eta, int njet, bool triggerpass, bool el_conv){


  map<TString,TH1*>::const_iterator mapit;  
    
  double eff_fake(0.);  
 
  TString hist = "h_pt_trig";
  if(triggerpass) hist +="pass_";
  else hist += "fail_";
  
  if(el_conv)hist += "conv";
  else {
    if(fabs(eta) < 1.05) hist += "nonconv_barrel";
    else hist += "nonconv_endcap";
  }
 
  
  mapit = _EfficiencyMap.find(hist);
  
  if(mapit!=_EfficiencyMap.end()){
    int binx=mapit->second->FindBin(pt);  	
    eff_fake =  mapit->second->GetBinContent(binx);    
  }
  else NoHist(hist); 


  //// INITIAL METHOD OF SYSTEMATICS UPDATE NEEDED
  if(sys==1) eff_fake*=1.1;
  if(sys==-1) eff_fake*=0.7;

  return eff_fake;
  
}

float WRHNCommonLeptonFakes::getEfficiency_muon(int sys, float pt, float eta, int njets, TString region){
  
  map<TString,TH2*>::const_iterator mapit;  
  
  float eff_real(0.);

  if(pt > 200.) pt = 199.;

  if(njets==0) mapit = _2DEfficiencyMap.find((region+"_ptetajet0").Data());
  else if(njets==1) mapit = _2DEfficiencyMap.find((region+"_ptetajet1").Data());
  else if(njets<4) mapit = _2DEfficiencyMap.find((region +"_ptetajet23").Data());
  else  mapit = _2DEfficiencyMap.find((region+ "_ptetajet4").Data());        
  
  if(mapit!=_2DEfficiencyMap.end()){
    int binx =  mapit->second->FindBin(pt,njets);  
    eff_real =  mapit->second->GetBinContent(binx);
  }
  else NoHist("real_eff_pteta");
   
  if(sys==0)  return eff_real;

  /// Current method :: need to check systematic
  if(sys==1)eff_real *=1.05;
  if(sys==-1)  eff_real *=0.95; 

  // Correct for up systematics > 100 %
  if(eff_real>1.)eff_real=1.0;
  
  return eff_real;
}


float WRHNCommonLeptonFakes::getFakeRate_muons(int sys, bool isHF,float pt, int njets, float eta, bool nearjet, TString region){
  
  map<TString,TH2*>::const_iterator mapit;  
  map<TString,TH1*>::const_iterator mapit1D;  
  
  //// pt for fakes goes up to 80 GeV
  if(nearjet && (pt > 300.)) pt = 300;
  if(!nearjet && (pt > 65.)) pt = 65.; 


  TString cut; 
  if(nearjet){
    cut="_pt_close";
  }
  else{
    if(fabs(eta) < 1.05){
      if(isHF&&njets==1) cut += "_pt_nj1_barrel";
      if(isHF&&njets>1) cut += "_pt_gtnj1_barrel";
      if(!isHF) cut += "_pt_gtnj0_barrel";
    }
    else{
      if(isHF&&njets==1) cut += "_pt_nj1_endcap";
      if(isHF&&njets>1) cut += "_pt_gtnj1_endcap";
      if(!isHF) cut += "_pt_gtnj0_endcap";
    }    
  }
  
  if(isHF)region+="HF";

  else region += "LF";

 
  if(m_debug) cout << "Calculating Fakes with 2D jet/pT parameterization" << endl;
  
  double eff_fake=0.;    
  //  mapit = _2DEfficiencyMap.find("h_" + region + cut);
  mapit1D = _EfficiencyMap.find("h_" + region + cut);
  

  if(nearjet){
    eff_fake= GetFitfakeRate(pt, (region + cut));      
  }
  else{    
    if(pt > 30.){    
      /// Get fake rate from fit
      eff_fake= GetFitfakeRate(pt, (region + cut));      
      
    }
    else{
      if(mapit1D!=_EfficiencyMap.end()){
	int binx=mapit1D->second->FindBin(pt); 	  
	eff_fake =  mapit1D->second->GetBinContent(binx);       
      }
      else NoHist("h_" + region + cut); 
    }
  }
  

  if(apply_scalefactor&& pt < 40){
    if(njets == 0) eff_fake*= 1.09; // <eff_fake>_njet=x / <eff_fake>
    if(njets == 1) eff_fake*= 0.97;
  }

  if(apply_scalefactor){
    if(pt< 35.){
      if(region.Contains("trigiso")) eff_fake*=1.2;
      else eff_fake*=1.4;
    }
    else if(pt < 50){      
      eff_fake*=1.1;
    }    
  }


  if(sys==1) eff_fake*=1.3; //// Rough at the moment : more detailed values (per bin) to come
  if(sys==-1) eff_fake*=0.7; //// Rough at the moment : more detailed values (per bin) to come

  return eff_fake;
}


float WRHNCommonLeptonFakes::getFakeRate_muonsold(int sys, bool isHF,float pt, int njets,float eta, bool nearjet, TString region){
  
  map<TString,TH2*>::const_iterator mapit;  
  map<TString,TH1*>::const_iterator mapit1D;  
  
  if(nearjet && (pt > 300.)) pt = 300;
  if(!nearjet && (pt > 80.)) pt = 79;

  //// pt for fakes goes up to 80 GeV
  if((njets == 0) && (pt > 49.)) pt = 49.; /// 0 jet bin 50+ GeV has large contamination of real prompt muons. 
  if(njets > 6) njets=6; /// Only parameterise up to 6 jets (reduce ttbar)

  TString cut; 
  if(nearjet){
    cut="_pt_close";
  }

  if(!nearjet){
    cut="_ptnjets";
  }
  
  if(isHF) region+="HF";
  else region += "LF";

 
  if(m_debug) cout << "Calculating Fakes with 2D jet/pT parameterization" << endl;
  
  double eff_fake=0.;  
  
  mapit = _2DEfficiencyMap.find("h_" + region + cut);
  mapit1D = _EfficiencyMap.find("h_" + region + cut);
  
  if(nearjet){
    if(mapit1D!=_EfficiencyMap.end()){
      int binx=mapit1D->second->FindBin(pt);  	
      eff_fake =  mapit1D->second->GetBinContent(binx);    
    }
    else NoHist("h_" + region + cut); 
  }
  else{
    if(mapit!=_2DEfficiencyMap.end()){
      int binx=mapit->second->FindBin(pt,njets); 	  
      eff_fake =  mapit->second->GetBinContent(binx);       
    }
    else NoHist("h_" + region + cut); 
  }



 if(apply_scalefactor){
    if(!isHF){
      if(pt < 20.){
	if(region.Contains("trigiso")) eff_fake*=1.2;
	else eff_fake*=1.4;
      }
      else if(pt< 35.){
	if(region.Contains("trigiso")) eff_fake*=1.2;
	else eff_fake*=1.4;
      }
      else if(pt < 50){      
	eff_fake*=1.1;
      }
    }
    else{ 
      if(region.Contains("trigiso")) eff_fake*=1.2;
      else eff_fake*=1.4;
    }
  }



  if(sys==1) eff_fake*=1.3;
  if(sys==-1) eff_fake*=0.7;

  return eff_fake;
}




float WRHNCommonLeptonFakes::getHSTEfficiency(int isys, float pt, float eta, int njets, TString region){

  map<TString,TH2*>::const_iterator mapit;  
 
  float eff_real(0.);

  TString sys = "";
  if(isys==1) sys+="_HSTup";
  if(isys==-1) sys+="_HSTdown";
 
  if(njets==0) mapit = _2DEfficiencyMapHST.find((region+"_ptetajet0"+sys).Data());
  else if(njets==1) mapit = _2DEfficiencyMapHST.find((region+"_ptetajet1"+sys).Data());
  else if(njets<4) mapit = _2DEfficiencyMapHST.find((region +"_ptetajet23"+sys).Data());
  else  mapit = _2DEfficiencyMapHST.find((region+ "_ptetajet4"+sys).Data());        
  
  if(mapit!=_2DEfficiencyMapHST.end()){
    int binx =  mapit->second->FindBin(pt,eta);  
    eff_real =  mapit->second->GetBinContent(binx);
    

  }
  else NoHist("real_eff_pteta");
    

  
  return eff_real;

}


float WRHNCommonLeptonFakes::getHSTFakeRate(int isys, bool isHF,float pt,float eta, int njets, bool nearjet, TString region){
  
  map<TString,TH1*>::const_iterator mapit1D;  

  
  TString sys = "";
  if(isys==1) sys+="_HSTup";
  if(isys==-1) sys+="_HSTdown";
  
  
  if(pt > 50.) pt = 49.; /// 0 jet bin 50+ GeV has large contamination of real prompt muons. 
  if(njets > 6) njets=6; /// Only parameterise up to 6 jets (reduce ttbar)

  
  TString cut; 
  if(nearjet){
    cut="_pt_close";
  }
  else{
    if(fabs(eta) < 1.05){
      if(isHF&&njets==1) cut += "_pt_nj1_barrel"+sys;
      if(isHF&&njets>1) cut += "_pt_gtnj1_barrel"+sys;
      if(!isHF) cut += "_pt_gtnj0_barrel"+sys;
    }
    else{
      if(isHF&&njets==1) cut += "_pt_nj1_endcap"+sys;
      if(isHF&&njets>1) cut += "_pt_gtnj1_endcap"+sys;
      if(!isHF) cut += "_pt_gtnj0_endcap"+sys;
    }    
  }
  
  if(isHF)region+="HF";
  else region += "LF";
   
  double eff_fake=0.;    
  mapit1D = _EfficiencyMapHST.find("h_" + region + cut);
  
  if(mapit1D!=_EfficiencyMapHST.end()){
    int binx=mapit1D->second->FindBin(pt); 	  
    eff_fake =  mapit1D->second->GetBinContent(binx);       
  }
  else NoHist("h_" + region + cut); 

  if(njets == 0) eff_fake*= 1.09; // <eff_fake>_njet=x / <eff_fake>
  if(njets == 1) eff_fake*= 0.97;
  
  return eff_fake;
}



float WRHNCommonLeptonFakes::HSTWeightF(int sys, TLorentzVector muon, std::vector<TLorentzVector> jets, bool isHF, TString region){
  
  float _mu1_pt=muon.Pt();
  float _mu1_eta=muon.Eta();

  int njets= jets.size();
  
  _mu1_pt = _mu1_pt/1000.;

  
  bool mu1jet_overlap=false;
  for(vector<TLorentzVector>::iterator it = jets.begin(); it!=jets.end();it++){
    if(muon.DeltaR(*it) < 0.4) mu1jet_overlap =true; 
  }
  
  float rateHST = getHSTFakeRate(sys, isHF,  _mu1_pt,_mu1_eta, njets, mu1jet_overlap, region);
  
  return rateHST;

}


float WRHNCommonLeptonFakes::HSTWeightR(int sys, TLorentzVector muon, std::vector<TLorentzVector> jets, TString region){

  float _mu1_pt=muon.Pt();
  float _mu1_eta=muon.Eta();
  int njets= jets.size();

  _mu1_pt = _mu1_pt/1000.;
  
  float rateHST = getHSTEfficiency(sys,_mu1_pt, _mu1_eta,njets,region);

  return rateHST;
}



void WRHNCommonLeptonFakes::NoHist(TString hist){
  
  cout << "No Histogram found for string " << hist << endl;
  cout << "Possible hist are : " << endl;

  for(map<TString, TH1*>::iterator mit = _EfficiencyMap.begin(); mit != _EfficiencyMap.end(); mit++){
    cout << mit->first << endl;  
  }
  

  for(map<TString, TH1*>::iterator mit = _EfficiencyMapHST.begin(); mit != _EfficiencyMapHST.end(); mit++){
    cout << mit->first << endl;  
  }

  for(map<TString, TH2*>::iterator mit = _2DEfficiencyMap.begin(); mit != _2DEfficiencyMap.end(); mit++){
    cout << mit->first <<" " << mit->second << endl;    
  }  
  exit(1);
}

void WRHNCommonLeptonFakes::NullTotals(){
  fsys=0;
  rsys=0;
  
}


void WRHNCommonLeptonFakes::CheckFile(TFile* file){

  if(file) cout << "WRHNCommonLeptonFakes: File " << file->GetName() << " was found." << endl;
  else cout << "WRHNCommonLeptonFakes  " << file->GetName()  << "  : ERROR Rootfile failed to open." << endl;
  
  if(!file) exit(0);
  return;
}

float WRHNCommonLeptonFakes::GetFitfakeRate(float pt, TString histname){


  float f(0.), p0(0.), p1(0.), p0err(0.), p1err(0.);
 

  if(histname.Contains("tightHF_pt_nj1_barrel")){
    p0 = -0.05218;
    p0err = 0.02854;
    p1 = 0.0031;
    p1err= 0.00094;
  }
  if(histname.Contains("tightHF_pt_nj1_endcap")){
    p0 = 0.013065;
    p0err = 0.027;
    p1 = 0.00148;
    p1err= 0.000872;
  }
  if(histname.Contains("tightHF_pt_gtnj1_barrel")){
    p0 = -0.04741;
    p0err =0.044;
    p1 = 0.00305;
    p1err= 0.00146;
  }
  if(histname.Contains("tightHF_pt_gtnj1_endcap")){
    p0 = 0.05375;
    p0err =0.0384;
    p1 = 0.000396;
    p1err= 0.00123;
  }
  if(histname.Contains("tightLF_pt_gtnj0_barrel")){
    p0 = -0.0932;
    p0err =0.0350;
    p1 = 0.00512;
    p1err= 0.00117;
  }  
  if(histname.Contains("tightLF_pt_gtnj0_endcap")){
    p0 = -0.0787;
    p0err = 0.0358;
    p1 = 0.00495;
    p1err= 0.00119;
  }
  if(histname.Contains("tightHF_pt_close")){
    p0 = -0.0783;
    p0err =0.0276;
    p1 = 0.00162;
    p1err= 0.000293;
  }  
  if(histname.Contains("tightLF_pt_close")){
    p0 = -0.005469;
    p0err =0.07090;
    p1 = 0.001478;
    p1err= 0.0007132;
  }
  
  

  if(histname.Contains("tight_trigisoHF_pt_nj1_barrel")){
    p0 = -0.105;
    p0err =0.0797;
    p1 = 0.00744;
    p1err= 0.00262;
  }
  if(histname.Contains("tight_trigisoHF_pt_nj1_endcap")){
    p0 = 0.0659;
    p0err =0.0685;
    p1 = 0.00279;
    p1err= 0.00221;
  }
  if(histname.Contains("tight_trigisoHF_pt_gtnj1_barrel")){
    p0 = 0.144;
    p0err =0.1504;
    p1 = 0.00744;
    p1err= 0.00262;
  }  
  if(histname.Contains("tight_trigisoHF_pt_gtnj1_endcap")){
    p0 = 0.157;
    p0err =0.0905;
    p1 = 0.000515;
    p1err= 0.00286;
  }  
  if(histname.Contains("tight_trigisoLF_pt_gtnj0_barrel")){
    p0 = -0.085;
    p0err = 0.089;
    p1 = 0.0085;
    p1err= 0.0029;
  }  
  if(histname.Contains("tight_trigisoLF_pt_gtnj0_endcap")){
    p0 = 0.0106;
    p0err =0.0798;
    p1 = 0.00539;
    p1err= 0.00263;
  }
  if(histname.Contains("tight_trigisoHF_pt_close")){
    p0 = -0.02932;
    p0err =0.2493;
    p1 = 0.001316;
    p1err= 0.002585;
  }
  if(histname.Contains("tight_trigisoLF_pt_close")){
    p0 = -0.3127;
    p0err =0.2683;
    p1 = 0.00419;
    p1err= 0.00258;
  }
     

  f = p0 + pt* p1;  

  return f;  
}


float WRHNCommonLeptonFakes::CalculateDiLepMMWeight(float r1, float fr1, float r2, float fr2, bool mu1Tight, bool mu2Tight){
 
  
  // Function calculates event weight given r/f of two muons in the event
  double alpha = 1./((r1- fr1)*(r2- fr2));

  // Initialise weight
  float w_mm=-999.;
    
  // Terms for RF and FR events from MM
  double termTT = alpha*(r1*fr2*(fr1-1.)*(1.-r2) + (fr1*r2*(r1-1.)*(1.-fr2)));
  double termTL = alpha*(r1*fr2*((1-fr1)*r2) + (fr1*r2*(1.-r1)*fr2));
  double termLT = alpha*(r1*fr2*(fr1*(1.-r2))+ (fr1*r2*(1.-fr2)*r1));
  double termLL = -2.*alpha*(r1*fr2*(fr1*r2));
  
  
  // Term for FF events
  termTT += alpha*fr1*fr2*((1.-r1)*(1.-r2));
  termTL += alpha*fr1*fr2*r2*(r1-1.);
  termLT += alpha*fr1*fr2*r1*(r2-1.);
  termLL += alpha*r1*r2*(fr1*fr2);

  
  // decide which type of event we have so to return correct weight
  bool isLL = (!mu1Tight&&!mu2Tight);
  bool isLT = (!mu1Tight&&mu2Tight);
  bool isTL = (mu1Tight && !mu2Tight);
  bool isTT = (mu1Tight && mu2Tight);

  if(isLL)w_mm = termLL;
  if(isTL)w_mm = termTL;
  if(isLT)w_mm = termLT;
  if(isTT)w_mm=  termTT;  


  return w_mm;   
}


double WRHNCommonLeptonFakes::lepton_weight(bool loose, double r, double f) {
  // Function to get event weight for a single muon event
  double nl=loose ? 1 :0;
  double nt=!loose ? 1 :0;
  if(r==f) return 0.;
  double a=1./(r-f);
  float nf=a*f*r*nl;
  float nr=a*f*(r - 1.)*nt;
  return nf+nr;
}

void WRHNCommonLeptonFakes::APPLY_scalefactor(bool applysf) {
  apply_scalefactor = applysf;
}
