// STL include(s):                                                                                                                                                       
#include <stdexcept>
#include <sstream>
#include <iostream>


// ROOT include(s):                                                                                                                                                                
#include "TFile.h"
#include "TSystem.h"
#include "TROOT.h"
#include "TRandom.h"
#include "TDirectory.h"
#include "TLorentzVector.h"
#include "TH2.h"

/// local includes
#include "WRHNCommonLeptonFakes/WRHNCommonLeptonFakes.h"

using namespace std;



TDirectory* WRHNCommonLeptonFakes::getTemporaryDirectory(void) const
{
  //                                                                                                                                                                                
  // Create a unique directory in memory to hold the histograms:                                                                                                                      //                                                                                                                                                                                 
  gROOT->cd();
  TDirectory* tempDir = 0;
  int counter = 0;
  while (not tempDir) {
    // First, let's find a directory name that doesn't exist yet:                                                                                                                    
    std::stringstream dirname;
    dirname << "WRHNCommonLeptonFakes_%i" << counter;
    if (gROOT->GetDirectory((dirname.str()).c_str())) {
      ++counter;
      continue;
    }
    // Let's try to make this directory:                                                                                                                                             
    tempDir = gROOT->mkdir((dirname.str()).c_str());

  }

  return tempDir;
}


void WRHNCommonLeptonFakes::InitialiseFake(){
  
  bool failedinitialisation=false;

  cout << "WRHNCommonLeptonFakes : Initializing" << endl;
  cout << "Accessing Fake Ntuple at " << path_to_root_files+"FakeRateDiLeptonWRHN.root" << endl;

  ///// 2012 Initialosation

  // Remember which TDirectory the system is in at the beginning of the method:                                                                                                      
  TDirectory* origDir = gDirectory;

  TFile* file_Muon_RealFake_Eff  = TFile::Open((path_to_root_files+"FakeRateDiLeptonWRHN.root").c_str());
  TFile* file_Muon_RealFake_HSTEff = TFile::Open((path_to_root_files+"FakeRateDiLeptonWRHN_HST.root").c_str());
  TFile* file_Electron_Fake_Eff = TFile::Open((path_to_root_files+"elfake.root").c_str());
  TFile* file_Electron_Real_Eff= TFile::Open((path_to_root_files+"elrealeff.root").c_str());				       

  
  
  if(file_Muon_RealFake_Eff) cout << "WRHNCommonLeptonFakes: File " << file_Muon_RealFake_Eff->GetName() << " was found." << endl;
  else cout << "WRHNCommonLeptonFakes  " << file_Muon_RealFake_Eff->GetName()  << "  : ERROR Rootfile failed to open." << endl;

  if(file_Electron_Fake_Eff) cout << "WRHNCommonLeptonFakes: File " << file_Electron_Fake_Eff->GetName() << " was found." << endl;
  else cout << "WRHNCommonLeptonFakes  " << file_Electron_Fake_Eff->GetName()  << "  : ERROR Rootfile failed to open." << endl;
  if(file_Electron_Real_Eff) cout << "WRHNCommonLeptonFakes: File " << file_Electron_Real_Eff->GetName() << " was found." << endl;
  else cout << "WRHNCommonLeptonFakes  " << file_Electron_Real_Eff->GetName()  << "  : ERROR Rootfile failed to open." << endl;

  
  if(!(file_Muon_RealFake_Eff || file_Electron_Fake_Eff || file_Electron_Real_Eff)) exit(0);

  //// Adding 2012 histograms to map
  
  
  // Create a unique directory in memory to hold the histograms:                                                                                                                     
  TDirectory* tempDir = getTemporaryDirectory();
  tempDir->cd();
  
  //// Efficiency for mumu channel
 
  _2DEfficiencyMap["real_eff_ptetajet0"] = dynamic_cast<TH2*>((file_Muon_RealFake_Eff->Get("Efficiency_zmasstight_pteta_jet0"))->Clone());
  _2DEfficiencyMap["real_eff_ptetajet1"] = dynamic_cast<TH2*>((file_Muon_RealFake_Eff->Get("Efficiency_zmasstight_pteta_jet1"))->Clone());
  _2DEfficiencyMap["real_eff_ptetajet23"] = dynamic_cast<TH2*>((file_Muon_RealFake_Eff->Get("Efficiency_zmasstight_pteta_jet23"))->Clone());
  _2DEfficiencyMap["real_eff_ptetajet4"] = dynamic_cast<TH2*>((file_Muon_RealFake_Eff->Get("Efficiency_zmasstight_pteta_jet4"))->Clone());
  
  /// Efficiency for muons in emu channel (has trigger isolation in loose sample
  _2DEfficiencyMap["real_eff_trigiso_ptetajet0"] = dynamic_cast<TH2*>((file_Muon_RealFake_Eff->Get("Efficiency_trigiso_pteta_jet0"))->Clone());
  _2DEfficiencyMap["real_eff_trigiso_ptetajet1"] = dynamic_cast<TH2*>((file_Muon_RealFake_Eff->Get("Efficiency_trigiso_pteta_jet1"))->Clone());
  _2DEfficiencyMap["real_eff_trigiso_ptetajet23"] = dynamic_cast<TH2*>((file_Muon_RealFake_Eff->Get("Efficiency_trigiso_pteta_jet23"))->Clone());
  _2DEfficiencyMap["real_eff_trigiso_ptetajet4"] = dynamic_cast<TH2*>((file_Muon_RealFake_Eff->Get("Efficiency_trigiso_pteta_jet4"))->Clone());


  /// Efficiency for electrons (kirills histograms) in ee of emu channel
  _2DEfficiencyMap["real_eff_el_fail_ptetajet0"] = dynamic_cast<TH2*>((file_Electron_Real_Eff->Get("h_EtaPtrate_RE_trigFAIL_2d_njeq0_e24vhimedium1ORe60medium1"))->Clone());
  _2DEfficiencyMap["real_eff_el_pass_ptetajet0"] = dynamic_cast<TH2*>((file_Electron_Real_Eff->Get("h_EtaPtrate_RE_trigPASS_2d_njeq0_e24vhimedium1ORe60medium1"))->Clone());
  _2DEfficiencyMap["real_eff_el_fail_ptetajet1"] = dynamic_cast<TH2*>((file_Electron_Real_Eff->Get("h_EtaPtrate_RE_trigFAIL_2d_njge1_e24vhimedium1ORe60medium1"))->Clone());
  _2DEfficiencyMap["real_eff_el_pass_ptetajet1"] = dynamic_cast<TH2*>((file_Electron_Real_Eff->Get("h_EtaPtrate_RE_trigPASS_2d_njge1_e24vhimedium1ORe60medium1"))->Clone());

  /// HST plots
  //_2DEfficiencyMapHST["real_eff_ptetajet0"] = (TH2*)(file_Muon_RealFake_HSTEff->Get("Efficiency_pteta_jet0"));
  //_2DEfficiencyMapHST["real_eff_ptetajet1"] = (TH2*)(file_Muon_RealFake_HSTEff->Get("Efficiency_pteta_jet1"));
  //_2DEfficiencyMapHST["real_eff_ptetajet23"] = (TH2*)(file_Muon_RealFake_HSTEff->Get("Efficiency_pteta_jet23"));
  //_2DEfficiencyMapHST["real_eff_ptetajet4"] = (TH2*)(file_Muon_RealFake_HSTEff->Get("Efficiency_pteta_jet4"));
  

  /// Efficiency for muons in emu channel (has trigger isolation in loose sample
  //_2DEfficiencyMapHST["real_eff_trigiso_ptetajet0"] = (TH2*)(file_Muon_RealFake_HSTEff->Get("Efficiency_trigiso_pteta_jet0"));
  //_2DEfficiencyMapHST["real_eff_trigiso_ptetajet1"] = (TH2*)(file_Muon_RealFake_HSTEff->Get("Efficiency_trigiso_pteta_jet1"));
  //_2DEfficiencyMapHST["real_eff_trigiso_ptetajet23"] = (TH2*)(file_Muon_RealFake_HSTEff->Get("Efficiency_trigiso_pteta_jet23"));
  //_2DEfficiencyMapHST["real_eff_trigiso_ptetajet4"] = (TH2*)(file_Muon_RealFake_HSTEff->Get("Efficiency_trigiso_pteta_jet4"));

 
  //// Adding 2012 fake rate hists
  
  /// Adding muon fake histograms to map
  regions.clear();
  regions.push_back("2mud0sigUB5_tight");
  regions.push_back("2mud0sigUB5_tight_trigiso");
 
  //// 2-Dimensional
  for(unsigned int reg=0; reg< regions.size(); reg++){
    _2DEfficiencyMap[("h_" + regions[reg] + "HF_ptnjets").Data()] = dynamic_cast<TH2*>((file_Muon_RealFake_Eff->Get(("h_" + regions[reg] + "_HF_ptnjets").Data()))->Clone());
    _2DEfficiencyMap[("h_" + regions[reg] + "LF_ptnjets").Data()] = dynamic_cast<TH2*>((file_Muon_RealFake_Eff->Get(("h_" + regions[reg] + "_LF_ptnjets").Data()))->Clone());
    
    _2DEfficiencyMapHST[("h_" + regions[reg] + "HF_ptnjets").Data()] = dynamic_cast<TH2*>((file_Muon_RealFake_HSTEff->Get(("h_" + regions[reg] + "_HF_ptnjets").Data()))->Clone());
    _2DEfficiencyMapHST[("h_" + regions[reg] + "LF_ptnjets").Data()] = dynamic_cast<TH2*>((file_Muon_RealFake_HSTEff->Get(("h_" + regions[reg] + "_LF_ptnjets").Data()))->Clone());
    
  }

  //// 1-Dimensional
  for(unsigned int reg=0; reg< regions.size(); reg++){
    _EfficiencyMap[("h_" + regions[reg] + "HF_pt_close").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_Eff->Get(("h_" + regions[reg] + "_HF_pt_close").Data()))->Clone());
    _EfficiencyMap[("h_" + regions[reg] + "LF_pt_close").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_Eff->Get(("h_" + regions[reg] + "_LF_pt_close").Data()))->Clone());

    _EfficiencyMapHST[("h_" + regions[reg] + "HF_pt_close").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_HSTEff->Get(("h_" + regions[reg] + "_HF_pt_close").Data()))->Clone());
    _EfficiencyMapHST[("h_" + regions[reg] + "LF_pt_close").Data()] = dynamic_cast<TH1*>((file_Muon_RealFake_HSTEff->Get(("h_" + regions[reg] + "_LF_pt_close").Data()))->Clone());
  }

  
  /// Adding electron fake histograms to map
  
  // Trigger pass
  _EfficiencyMap[("h_pt_trigpass_conv")] = dynamic_cast<TH1*>(dynamic_cast<TH1*>(file_Electron_Fake_Eff->Get(("h_Ptrate_FR_trigPASS_sub_conv_e24vhimedium1ORe60medium1")))->Clone());
  _EfficiencyMap[("h_pt_trigpass_nonconv_barrel")] = dynamic_cast<TH1*>(dynamic_cast<TH1*>(file_Electron_Fake_Eff->Get(("h_Ptrate_FR_trigPASS_sub_nonconvANDbarrel_e24vhimedium1ORe60medium1")))->Clone());
  _EfficiencyMap[("h_pt_trigpass_nonconv_endcap")] = dynamic_cast<TH1*>(dynamic_cast<TH1*>(file_Electron_Fake_Eff->Get(("h_Ptrate_FR_trigPASS_sub_nonconvANDendcap_e24vhimedium1ORe60medium1")))->Clone());
  

  
  // Trigger fail
  _EfficiencyMap[("h_pt_trigfail_conv")] = dynamic_cast<TH1*>((file_Electron_Fake_Eff->Get(("h_Ptrate_FR_trigFAIL_sub_conv_e24vhimedium1ORe60medium1")))->Clone());
  _EfficiencyMap[("h_pt_trigfail_nonconv_barrel")] = dynamic_cast<TH1*>((file_Electron_Fake_Eff->Get(("h_Ptrate_FR_trigFAIL_sub_nonconvANDbarrel_e24vhimedium1ORe60medium1")))->Clone());
  _EfficiencyMap[("h_pt_trigfail_nonconv_endcap")] = dynamic_cast<TH1*>((file_Electron_Fake_Eff->Get(("h_Ptrate_FR_trigFAIL_sub_nonconvANDendcap_e24vhimedium1ORe60medium1")))->Clone());



  for(map<TString, TH1*>::iterator mit = _EfficiencyMap.begin(); mit != _EfficiencyMap.end(); mit++){
    if(!mit->second){
      cout << "Failed " << mit->first << endl;
      failedinitialisation=true;
    }
  }
  for(map<TString, TH2*>::iterator mit = _2DEfficiencyMap.begin(); mit != _2DEfficiencyMap.end(); mit++){
    if(!mit->second){
      cout << "Failed " << mit->first << endl;
      failedinitialisation=true;
    }
  }
  
  if(failedinitialisation){
    cout << "Not all histograms could be initialised, this is a bug so am exiting" << endl;
  }
  else {
    
    cout << "WRHNCommonLeptonFakes : Initialsation was successful " << endl;
    cout << "WRHNCommonLeptonFakes : Default setting in MeV" <<  endl;
    cout << "WRHNCommonLeptonFakes : To Use GeV set third argument of constructor true" << endl;
  }
  SystMap.clear();
  for(vector<TString>::iterator rit = regions.begin(); rit!=regions.end() ; rit++){
    SystMap[*rit]=0.;
  }

  // Now we can close the file:                                                                                                                                                      
  file_Muon_RealFake_Eff->Close();
  file_Muon_RealFake_HSTEff->Close();
  file_Electron_Fake_Eff->Close();
  file_Electron_Real_Eff->Close();
  
  delete file_Muon_RealFake_Eff;
  delete file_Electron_Fake_Eff;
  delete file_Electron_Real_Eff;
  delete file_Muon_RealFake_HSTEff;


  // Return to the directory we were in before the function call:                                                                                                                    
  origDir->cd();
  
  return;
}


/// Constructor
WRHNCommonLeptonFakes::WRHNCommonLeptonFakes(std::string path,bool usegev){

  path_to_root_files = path;
  useGeV = usegev;
  InitialiseFake();
  m_debug=false;
  NullTotals();
}


/// Destructor
WRHNCommonLeptonFakes::~WRHNCommonLeptonFakes() {
  closefile();   
  CutHists.clear();
}



void WRHNCommonLeptonFakes::ApplyFakeSystematic(int type){
 
  //  if(type==0)cout << "WRHNCommonLeptonFakes : Running in default mode f [no systematic applied] " << endl;
  //  if(type==1)cout << "WRHNCommonLeptonFakes : Applying systematic f + sigma" << endl;
  //  if(type==-1)cout << "WRHNCommonLeptonFakes : Applying systematic f - sigma" << endl;
  
  fsys=type;
}

void WRHNCommonLeptonFakes::ApplyRealSystematic(int type ){
  
  //if(type==0)cout << "WRHNCommonLeptonFakes : Running in default mode r [no systematic applied] " << endl;
  //if(type==1)cout << "WRHNCommonLeptonFakes : Applying systematic r + sigma " << endl;
  //if(type==-1)cout << "WRHNCommonLeptonFakes : Applying systematic r - sigma " << endl;
  
  rsys=type;
}



//####################   DiELectron Function

//// Only uses preliminary r/f values for now

///// NO systematics

float WRHNCommonLeptonFakes::get_dilepton_eventweight(std::vector<TLorentzVector> muons, std::vector<TLorentzVector> electrons, std::vector<TLorentzVector> jets, bool ismu1_HF, bool ismu2_HF, vector<bool> are_muons_tight, vector<bool> are_electrons_tight, bool isel1_conv, bool isel2_conv, bool el1_triggermatched, bool el2_triggermatched , bool inGeV, TString channel){
    
  if(channel.Contains("emu")) {
    if(muons.size()!=1 || electrons.size()!=1) {
      cout << "Channel set to emu: but wrong number of leptons passed for this channel" << endl;
      return 0.;
    }
    return get_dilepton_emu_eventweight( muons,  electrons, jets, are_muons_tight.at(0), are_electrons_tight.at(0), ismu1_HF, isel1_conv, el1_triggermatched,inGeV);
    
  }
  if(channel.Contains("mumu")){
    if(muons.size()!=2) {
      cout << "Channel set to mumu: but wrong number of leptons passed for this channel" << endl;
      return 0.;

    }
    return get_dilepton_mm_eventweight(muons, jets, are_muons_tight.at(0), are_muons_tight.at(1),ismu1_HF, ismu2_HF, inGeV);    
  }
  
  if(channel.Contains("ee")){
    if(electrons.size()!=2) {
      cout << "Channel set to ee: but wrong number of leptons passed for this channel" << endl;
      return 0.;

    }
    return get_dilepton_ee_eventweight(electrons, jets, isel1_conv, isel2_conv, el1_triggermatched, el2_triggermatched, are_electrons_tight.at(0), are_electrons_tight.at(1), inGeV);
  }
  
  return 0.;
     
}



float  WRHNCommonLeptonFakes::get_dilepton_ee_eventweight(std::vector<TLorentzVector> electrons, std::vector<TLorentzVector> jets, bool _el1_conv,bool _el2_conv, bool _el1_triggerpass, bool _el2_triggerpass,bool isel1tight, bool isel2tight,bool inGeV){
  
  useGeV=inGeV;
  if(electrons.size()!=2) {
    cout << "DiLepton event weight requires 2 muons." << endl;
    return (0.);
  }
  
  float _el1_pt=electrons.at(0).Pt();
  float _el2_pt=electrons.at(1).Pt();

  float _el1_eta=electrons.at(0).Eta();
  float _el2_eta=electrons.at(1).Eta();

  int njets = jets.size();
  if(m_debug){
    cout << "WRHNCommonLeptonFakes::Event Summary " << endl;
    cout << "el1 pT = " << _el1_pt << endl;
    cout << "el2 pT = " << _el2_pt << endl;
  }
  if(!useGeV){    
    _el1_pt = _el1_pt/1000.;
    _el2_pt = _el2_pt/1000.;
  }
  
  //// Current electron histograms have pt max 200
  if(_el1_pt > 200.) _el1_pt = 199.;
  if(_el2_pt > 200.) _el2_pt = 199.;


  float fr1(0.),fr2(0.),r1(0.),r2(0.);  
  r1 = getEfficiency_electron(rsys,_el1_pt,_el1_eta, njets, _el1_triggerpass);
  r2 = getEfficiency_electron(rsys,_el2_pt,_el2_eta, njets, _el2_triggerpass);

  
  fr1=getFakeRate_electrons(fsys,_el1_pt, _el1_eta, njets, _el1_triggerpass, _el1_conv);
  fr2=getFakeRate_electrons(fsys,_el2_pt, _el2_eta, njets, _el2_triggerpass, _el2_conv);
  
  // Calculate event weight
  float ev_weight = CalculateDiLepMMWeight(r1,fr1,r2,fr2, isel1tight, isel2tight);
  
  return ev_weight;

}

float  WRHNCommonLeptonFakes::get_dilepton_emu_eventweight(std::vector<TLorentzVector> muons,  std::vector<TLorentzVector> electrons, std::vector<TLorentzVector> jets,bool ismu1tight, bool isel1tight, bool is_muonHF,bool is_elconv,bool is_el_trigpass, bool inGeV){

  useGeV=inGeV;
 
  float _mu1_pt=muons.at(0).Pt();
  float _mu1_eta=muons.at(0).Eta();
  
  float _el1_pt= electrons.at(0).Pt();
  float _el1_eta= electrons.at(0).Eta();
  
  bool mu1jet_overlap=false;
  for(vector<TLorentzVector>::iterator it = jets.begin(); it!=jets.end();it++){
    if(muons.at(0).DeltaR(*it) < 0.4) mu1jet_overlap =true; 
  }
  
  int njets= jets.size();
  
  if(!useGeV){    
    _mu1_pt = _mu1_pt/1000.;
    _el1_pt = _el1_pt/1000.;
  }

  
  //// Current electron histograms have pt max 200
  if(_el1_pt > 200.) _el1_pt = 199.;
  
 
  float fr1(0.),fr2(0.),r1(0.),r2(0.);  
 

  /// Check pt ordering
  if(muons.at(0).Pt() > electrons.at(0).Pt()) {
    r1 = getEfficiency_muon(rsys,_mu1_pt, _mu1_eta, njets, "real_eff_trigiso");
    r2 = getEfficiency_electron(rsys, _el1_pt, _el1_eta, njets,is_el_trigpass);

    fr1=getFakeRate_muons(fsys,is_muonHF,_mu1_pt, njets, mu1jet_overlap,"2mud0sigUB5_tight_trigiso" );
    fr2=getFakeRate_electrons(fsys,_el1_pt,_el1_eta, njets, is_el_trigpass, is_elconv);     
    
  }
  else {
    r2 = getEfficiency_muon(rsys,_mu1_pt, _mu1_eta, njets, "real_eff_trigiso");
    r1 = getEfficiency_electron(rsys, _el1_pt, _el1_eta, njets,is_el_trigpass);

    fr2=getFakeRate_muons(fsys,is_muonHF,_mu1_pt, njets, mu1jet_overlap,"2mud0sigUB5_tight_trigiso" );
    fr1=getFakeRate_electrons(fsys,_el1_pt,_el1_eta, njets, is_el_trigpass, is_elconv); 

  }

    // Calculate event weight  
  return CalculateDiLepMMWeight(r1,fr1,r2,fr2, ismu1tight, isel1tight);

}


float  WRHNCommonLeptonFakes::get_dilepton_mm_eventweight( std::vector<TLorentzVector> muons, std::vector<TLorentzVector> jets,bool ismu1tight, bool ismu2tight,bool isHF1, bool isHF2,bool inGeV){
  
  useGeV=inGeV;
  if(muons.size()!=2) {
    cout << "DiLepton event weight requires 2 muons." << endl;
    return (0.);
  }
  
  float _mu1_pt=muons.at(0).Pt();
  float _mu1_eta=muons.at(0).Eta();
  float _mu2_pt=muons.at(1).Pt();
  float _mu2_eta=muons.at(1).Eta();

  bool mu1jet_overlap=false;
  bool mu2jet_overlap=false;
  for(vector<TLorentzVector>::iterator it = jets.begin(); it!=jets.end();it++){
    if(muons.at(0).DeltaR(*it) < 0.4) mu1jet_overlap =true; 
    if(muons.at(1).DeltaR(*it) < 0.4) mu2jet_overlap =true; 
  }
   
  int njets= jets.size();

  if(!useGeV){    
    _mu1_pt = _mu1_pt/1000.;
    _mu2_pt = _mu2_pt/1000.;
  }


  float fr1(0.),fr2(0.),r1(0.),r2(0.);  
  r1 = getEfficiency_muon(rsys,_mu1_pt, _mu1_eta,njets, "real_eff");
  r2 = getEfficiency_muon(rsys,_mu2_pt, _mu2_eta,njets, "real_eff");
 
 
  fr1=getFakeRate_muons(fsys,isHF1,_mu1_pt, njets, mu1jet_overlap,"2mud0sigUB5_tight");
  fr2=getFakeRate_muons(fsys,isHF2,_mu2_pt, njets, mu2jet_overlap,"2mud0sigUB5_tight");    
  
  
  return CalculateDiLepMMWeight(r1,fr1,r2,fr2, ismu1tight, ismu2tight);
}


  

float WRHNCommonLeptonFakes::CalculateDiLepMMWeight(float r1, float fr1, float r2, float fr2, bool mu1Tight, bool mu2Tight){
 
  
  // Function calculates event weight given r/f of two muons in the event
  double alpha = 1./((r1- fr1)*(r2- fr2));

  // Initialise weight
  float w_mm=-999.;
    
  // Terms for RF and FR events from MM
  double termTT = alpha*(r1*fr2*(fr1-1.)*(1.-r2) + (fr1*r2*(r1-1.)*(1.-fr2)));
  double termTL = alpha*(r1*fr2*((1-fr1)*r2) + (fr1*r2*(1.-r1)*fr2));
  double termLT = alpha*(r1*fr2*(fr1*(1.-r2))+ (fr1*r2*(1.-fr2)*r1));
  double termLL = -2.*alpha*(r1*fr2*(fr1*r2));
  
  
  // Term for FF events
  termTT += alpha*fr1*fr2*((1.-r1)*(1.-r2));
  termTL += alpha*fr1*fr2*r2*(r1-1.);
  termLT += alpha*fr1*fr2*r1*(r2-1.);
  termLL += alpha*r1*r2*(fr1*fr2);

  
  // decide which type of event we have so to return correct weight
  bool isLL = (!mu1Tight&&!mu2Tight);
  bool isLT = (!mu1Tight&&mu2Tight);
  bool isTL = (mu1Tight && !mu2Tight);
  bool isTT = (mu1Tight && mu2Tight);

  if(isLL)w_mm = termLL;
  if(isTL)w_mm = termTL;
  if(isLT)w_mm = termLT;
  if(isTT)w_mm=  termTT;  

  return w_mm;   
}


double WRHNCommonLeptonFakes::lepton_weight(bool loose, double r, double f) {
  // Function to get event weight for a single muon event
  double nl=loose ? 1 :0;
  double nt=!loose ? 1 :0;
  if(r==f) return 0.;
  double a=1./(r-f);
  float nf=a*f*r*nl;
  float nr=a*f*(r - 1.)*nt;
  return nf+nr;
}



float WRHNCommonLeptonFakes::getEfficiency_electron(int sys, float pt, float eta, int njet, bool passtrigger){

  map<TString,TH2*>::const_iterator mapit;  
    
  double eff_real(0.);  
 
  TString hist ="real_eff_el_";
  if(passtrigger) hist +="pass_ptetajet";
  else hist += "fail_ptetajet";
  
  if(njet==0 )hist += "0";
  else  hist += "1";
  
  mapit = _2DEfficiencyMap.find(hist);
  
  if(mapit!=_2DEfficiencyMap.end()){
    int binx=mapit->second->FindBin(pt,eta);  	
    eff_real =  mapit->second->GetBinContent(binx);    
  }
  else NoHist(hist); 
  
  //// INITIAL METHOD OF SYSTEMATICS
  if(sys==1) eff_real*=1.05;
  if(sys==-1) eff_real*=0.95;

  return eff_real;
  
}

float WRHNCommonLeptonFakes::getFakeRate_electrons(int sys, float pt, float eta, int njet, bool triggerpass, bool el_conv){


  map<TString,TH1*>::const_iterator mapit;  
    
  double eff_fake(0.);  
 
  TString hist = "h_pt_trig";
  if(triggerpass) hist +="pass_";
  else hist += "fail_";
  
  if(el_conv)hist += "conv";
  else {
    if(fabs(eta) < 1.05) hist += "nonconv_barrel";
    else hist += "nonconv_endcap";
  }
 
  
  mapit = _EfficiencyMap.find(hist);
  
  if(mapit!=_EfficiencyMap.end()){
    int binx=mapit->second->FindBin(pt);  	
    eff_fake =  mapit->second->GetBinContent(binx);    
  }
  else NoHist(hist); 


  //// INITIAL METHOD OF SYSTEMATICS UPDATE NEEDED
  if(sys==1) eff_fake*=1.1;
  if(sys==-1) eff_fake*=0.7;

  return eff_fake;
  
}

float WRHNCommonLeptonFakes::getEfficiency_muon(int sys, float pt, float eta, int njets, TString region){
  
  map<TString,TH2*>::const_iterator mapit;  
  
  float eff_real(0.);

  if(njets==0) mapit = _2DEfficiencyMap.find((region+"_ptetajet0").Data());
  else if(njets==1) mapit = _2DEfficiencyMap.find((region+"_ptetajet1").Data());
  else if(njets<4) mapit = _2DEfficiencyMap.find((region +"_ptetajet23").Data());
  else  mapit = _2DEfficiencyMap.find((region+ "_ptetajet4").Data());        
  
  if(mapit!=_2DEfficiencyMap.end()){
    int binx =  mapit->second->FindBin(pt,eta);  
    eff_real =  mapit->second->GetBinContent(binx);
  }
  else NoHist("real_eff_pteta");
   
  if(sys==0)  return eff_real;

  /// Current method :: need to check systematic
  if(sys==1)eff_real *=1.05;
  if(sys==-1)  eff_real *=0.95; 

  // Correct for up systematics > 100 %
  if(eff_real>1.)eff_real=1.0;
  
  return eff_real;
}


float WRHNCommonLeptonFakes::getFakeRate_muons(int sys, bool isHF,float pt, int njets, bool nearjet, TString region){
  
  map<TString,TH2*>::const_iterator mapit;  
  map<TString,TH1*>::const_iterator mapit1D;  
  
  //// pt for fakes goes up to 80 GeV
  if((njets == 0) && (pt > 49.)) pt = 49.; /// 0 jet bin 50+ GeV has large contamination of real prompt muons. 
  if(njets > 6) njets=6; /// Only parameterise up to 6 jets (reduce ttbar)

  TString cut; 
  if(nearjet){
    cut="_pt_close";
  }

  if(!nearjet){
    cut="_ptnjets";
  }
  
  if(isHF) region+="HF";
  else region += "LF";

 
  if(m_debug) cout << "Calculating Fakes with 2D jet/pT parameterization" << endl;
  
  double eff_fake=0.;  
  
  mapit = _2DEfficiencyMap.find("h_" + region + cut);
  mapit1D = _EfficiencyMap.find("h_" + region + cut);
  
  if(nearjet){
    if(mapit1D!=_EfficiencyMap.end()){
      int binx=mapit1D->second->FindBin(pt);  	
      eff_fake =  mapit1D->second->GetBinContent(binx);    
    }
    else NoHist("h_" + region + cut); 
  }
  else{
    if(mapit!=_2DEfficiencyMap.end()){
      int binx=mapit->second->FindBin(pt,njets); 	  
      eff_fake =  mapit->second->GetBinContent(binx);       
    }
    else NoHist("h_" + region + cut); 
  }

  if(region.Contains("trigiso")) eff_fake*=1.2;
  else eff_fake*=1.4;
  

  if(sys==1) eff_fake*=1.4;
  if(sys==-1) eff_fake*=0.7;

  return eff_fake;
}



float WRHNCommonLeptonFakes::getHSTEfficiency(int sys, float pt, float eta, int njets, TString region){

 map<TString,TH2*>::const_iterator mapit;  
  
  float eff_real(0.);
  
  if(njets==0) mapit = _2DEfficiencyMapHST.find((region+"_ptetajet0").Data());
  else if(njets==1) mapit = _2DEfficiencyMapHST.find((region+"_ptetajet1").Data());
  else if(njets<4) mapit = _2DEfficiencyMapHST.find((region +"_ptetajet23").Data());
  else  mapit = _2DEfficiencyMapHST.find((region+ "_ptetajet4").Data());        
  
  if(mapit!=_2DEfficiencyMapHST.end()){
    int binx =  mapit->second->FindBin(pt,eta);  
    eff_real =  mapit->second->GetBinContent(binx);
  }
  else NoHist("real_eff_pteta");
  

  
  if(sys==0)  return eff_real;

  /// Current method :: need to check systematic
  if(sys==1)eff_real *=1.05;
  if(sys==-1)  eff_real *=0.95; 

  // Correct for up systematics > 100 %
  if(eff_real>1.)eff_real=1.0;
  
  return eff_real;

}


float WRHNCommonLeptonFakes::getHSTFakeRate(int sys, bool isHF,float pt, int njets, bool nearjet, TString region){
  
  map<TString,TH2*>::const_iterator mapit;  
  map<TString,TH1*>::const_iterator mapit1D;  
  

  if(pt > 50.) pt = 49.; /// 0 jet bin 50+ GeV has large contamination of real prompt muons. 
  if(njets > 6) njets=6; /// Only parameterise up to 6 jets (reduce ttbar)

  TString cut; 
  if(nearjet)cut="_pt_close";
  else cut="_ptnjets";
  
  if(isHF) region+="HF";
  else region += "LF";

 
  if(m_debug) cout << "Calculating Fakes with 2D jet/pT parameterization" << endl;
  
  double eff_fake=0.;  
  
  mapit = _2DEfficiencyMapHST.find("h_" + region + cut);
  mapit1D = _EfficiencyMapHST.find("h_" + region + cut);
  
  if(nearjet){
    if(mapit1D!=_EfficiencyMapHST.end()){
      int binx=mapit1D->second->FindBin(pt);  	
      eff_fake =  mapit1D->second->GetBinContent(binx);    
    }
    else NoHist("h_" + region + cut); 
  }
  else{
    if(mapit!=_2DEfficiencyMapHST.end()){
      int binx=mapit->second->FindBin(pt,njets); 	  
      eff_fake =  mapit->second->GetBinContent(binx);       
    }
    else NoHist("h_" + region + cut); 
  }

  if(region.Contains("trigiso")) eff_fake*=1.2;
  else eff_fake*=1.4;


  if(sys==1) eff_fake*=1.1;
  if(sys==-1) eff_fake*=0.7;

  return eff_fake;
}



float WRHNCommonLeptonFakes::HSTWeight(int sys, TLorentzVector muon, std::vector<TLorentzVector> jets, bool isHF, TString region){
  
  float _mu1_pt=muon.Pt();

  int njets= jets.size();
  
  _mu1_pt = _mu1_pt/1000.;
  
  bool mu1jet_overlap=false;
  for(vector<TLorentzVector>::iterator it = jets.begin(); it!=jets.end();it++){
    if(muon.DeltaR(*it) < 0.4) mu1jet_overlap =true; 
  }
  
  float rateHST = getHSTFakeRate(sys, isHF,  _mu1_pt, njets, mu1jet_overlap, region);
  
  return rateHST;

}




float WRHNCommonLeptonFakes::HSTWeightR1(int sys, std::vector<TLorentzVector> muons, std::vector<TLorentzVector> jets, TString region){

  if(muons.size()!=2) return 0.;
  // Get rate from half of data sample                                                                                                                                               

  float _mu1_pt=muons.at(0).Pt();
  float _mu1_eta=muons.at(0).Eta();
  int njets= jets.size();

  _mu1_pt = _mu1_pt/1000.;
  
  float rateHST = getHSTEfficiency(sys,_mu1_pt, _mu1_eta,njets,region);

  return rateHST;
}

float WRHNCommonLeptonFakes::HSTWeightR2(int sys, std::vector<TLorentzVector> muons, std::vector<TLorentzVector> jets, TString region){

  if(muons.size()!=2) return 0.;
  // Get rate from half of data sample                                                                                                                                               

  float _mu2_pt=muons.at(1).Pt();
  float _mu2_eta=muons.at(1).Eta();


  int njets= jets.size();


  _mu2_pt = _mu2_pt/1000.;

  float rateHST = getHSTEfficiency(sys,_mu2_pt, _mu2_eta,njets,region);

  return rateHST;
}





void WRHNCommonLeptonFakes::NoHist(TString hist){
  
  cout << "No Histogram found for string " << hist << endl;
  cout << "Possible hist are : " << endl;

  for(map<TString, TH1*>::iterator mit = _EfficiencyMap.begin(); mit != _EfficiencyMap.end(); mit++){
    cout << mit->first << endl;  
  }

  for(map<TString, TH2*>::iterator mit = _2DEfficiencyMap.begin(); mit != _2DEfficiencyMap.end(); mit++){
    cout << mit->first <<" " << mit->second << endl;    
  }  
  exit(1);
}

void WRHNCommonLeptonFakes::NullTotals(){
  fsys=0;
  rsys=0;
  
}


